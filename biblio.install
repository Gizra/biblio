<?PHP
// $Id$
function biblio_install() {
  $result = array();

  drupal_install_schema('biblio');

  $result[] = _add_db_field_data();

  $result[] = _add_publication_types();

  $result[] = _add_custom_field_data();

  _enable_biblio_keyword_vocabulary();
  
  $result[] = _set_system_weight();
  
  if (count($result) == count(array_filter($result))) {
    drupal_set_message(t('The biblio module has successfully added its tables to the database.'));
  }
  else {
    drupal_set_message(t('Drupal encountered some errors while attempting to install the database tables for the biblio module.'), 'error');
  }
}

function biblio_enable() {
  _enable_biblio_keyword_vocabulary();
  _set_system_weight();
  //_enable_biblio_collection_vocabulary();
 // _add_biblio_keywords();
}

function biblio_uninstall(){
  $voc = taxonomy_get_vocabularies();
  foreach ($voc as $vid => $vocabulary) {
    if ($vocabulary->module == 'biblio')  taxonomy_del_vocabulary($vid);
  }
  
  $result = db_query("SELECT * FROM {node} WHERE type='biblio' ");
  while ($node = db_fetch_object($result)){
    db_query('DELETE FROM {node} WHERE nid = %d', $node->nid);
    db_query('DELETE FROM {node_revisions} WHERE nid = %d', $node->nid);
 
    // Remove this node from the search index if needed.
    if (function_exists('search_wipe')) {
      search_wipe($node->nid, 'node');
    }
  }

  drupal_uninstall_schema('biblio');
  
  $vars = db_query("SELECT * FROM {variable} WHERE name LIKE 'biblio_%'");
  while ($var = db_fetch_object($vars)) {
    variable_del($var->name);
  }
  
  cache_clear_all();
  
}

function _set_system_weight() {
  return update_sql("UPDATE {system} SET weight = 9 WHERE name = 'biblio'");
}

function _enable_biblio_keyword_vocabulary(){
    
  if ($vocabulary = taxonomy_vocabulary_load(variable_get('biblio_freetagging_vocab', 0))) {
    variable_set('biblio_keyword_vocabulary', $vocabulary->vid);
    $vocabulary->name = 'Biblio Keywords';
    $vocabulary->description = t('This is a free tag vocabulary which contains the key words from all nodes created by the biblio module');
    $vocabulary->help = t('Enter a comma separated list of words. Phrases containing commas should be enclosed in double quotes');
    $vocabulary->nodes = array('biblio' => 1);
    $vocabulary->hierarchy = 0;
    $vocabulary->relations = 1;
    $vocabulary->tags = 1;
    $vocabulary->multiple = 0;
    $vocabulary->required = 0;
    $vocabulary->weight = 0;
    $vocabulary->module = 'biblio';
    
    $vocabulary = (array) $vocabulary;
    taxonomy_save_vocabulary($vocabulary);    
    variable_del('biblio_freetagging_vocab');
  }
  
  if ($vocabulary = taxonomy_vocabulary_load(variable_get('biblio_keyword_vocabulary', 0))) {
      // Existing install. Add back forum node type, if the biblio
    // vocabulary still exists. Keep all other node types intact there.
    $vocabulary = (array) $vocabulary;
    $vocabulary['nodes']['biblio'] = 1;
    taxonomy_save_vocabulary($vocabulary);
  }
  else {
    // Create the biblio vocabulary if it does not exist.
    $vocabulary = array(
      'name' => 'Biblio Keywords',
      'description' => 'This is a free tag vocabulary which contains the keywords from all nodes created by the biblio module',
      'help' => 'Enter a comma separated list of words. Phrases containing commas should be enclosed in double quotes',
      'nodes' => array('biblio' => 1),
      'hierarchy' => 0,
      'relations' => 1,
      'tags' => 1,
      'multiple' => 0,
      'required' => 0,
      'weight' => 0,
      'module' => 'biblio',
    );
    taxonomy_save_vocabulary($vocabulary);
    variable_set('biblio_keyword_vocabulary', $vocabulary['vid']);
  }
  return $vocabulary['vid'];
}
function _enable_biblio_collection_vocabulary(){  
  if ($vocabulary = taxonomy_vocabulary_load(variable_get('biblio_collection_vocabulary', 0))) {
    // Existing install. Add back forum node type, if the biblio
    // vocabulary still exists. Keep all other node types intact there.
    $vocabulary = (array) $vocabulary;
    $vocabulary['nodes']['biblio'] = 1;
    taxonomy_save_vocabulary($vocabulary);
  }
  else {
    // Create the forum vocabulary if it does not exist. Assign the vocabulary
    // a low weight so it will appear first in forum topic create and edit
    // forms.
    $vocabulary = array(
      'name' => 'Biblio Collections',
      'description' => 'You may organize your publications into collections by adding a collection names to this vocabulary',
      'help' => '',
      'nodes' => array('biblio' => 1),
      'hierarchy' => 0,
      'relations' => 1,
      'tags' => 0,
      'multiple' => 1,
      'required' => 0,
      'weight' => 0,
      'module' => 'biblio',
    );
    taxonomy_save_vocabulary($vocabulary);
    variable_set('biblio_collection_vocabulary', $vocabulary['vid']);
    $default_collection = array(
      'name' => t('Default'),
      'description' => t("This is the collection that all biblio entries will be a part of if no other collection is selected. Deleting this term will render all your biblio entries inaccessable. (You've been warned!)" ),
      'parent' => array(),
      'relations' => array(),
      'synonyms' => '',
      'weight' => 0,
      'vid' => variable_get('biblio_collection_vocabulary', 0),
    );
    taxonomy_save_term($default_collection);
  }
  return $vocabulary['vid'];
  
}

/**
 * Copies keywords from the biblio_keyword column of the biblio table 
 * to a taxonomy vocabulary
 * 
 * @return none
 */
function _add_biblio_keywords() {
  set_time_limit(300);
  $kw_sep = variable_get('biblio_keyword_sep', ',');
  $vid = ($vid = variable_get('biblio_keyword_vocabulary', 0))? $vid:_enable_biblio_keyword_vocabulary();
  if ($vid ){
    $db_result  = db_query("SELECT b.biblio_keywords, b.nid, b.vid FROM {biblio} b");
    $result = array();
    while ($row = db_fetch_object($db_result)) {
      foreach(explode($kw_sep, $row->biblio_keywords) as $keyword) {
        $result[] = array('value' => trim($keyword), 'nid' => $row->nid, 'vid' =>$row->vid);
      }
      db_query('DELETE FROM {term_node} WHERE nid = %d', $row->nid);
    }
    $inserted = array();
    $count = 0;
    foreach ($result as $keywords) {
      // See if the term exists in the chosen vocabulary
      // and return the tid; otherwise, add a new record.
      $possibilities = taxonomy_get_term_by_name($keywords['value']);
      $term_tid = NULL; // tid match, if any.
      foreach ($possibilities as $possibility) {
        if ($possibility->vid == $vid) {
          $term_tid = $possibility->tid;
        }
      }

      if (!$term_tid) {
        $term = array('vid' => $vid, 'name' => $keywords['value']);
        $status = taxonomy_save_term($term);
        $term_tid = $term['tid'];
      }

      // Defend against duplicate, differently cased tags
      if (!isset($inserted[$keywords['vid']][$term_tid])) {
        db_query('INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)', $keywords['nid'], $keywords['vid'], $term_tid);
        $inserted[$keywords['vid']][$term_tid] = TRUE;
        $count++;
      }
    }
    return array('success' => TRUE, 'query' => 'Added '.$count. ' keywords to the biblio/taxonomy keyword vocabulary');
  }
  return array('success' => FALSE, 'query' => 'Biblio keyword vocabulary not available');
}


 
function biblio_schema() {
  $schema['biblio'] = array (
    'fields' => array (
      'nid' => array (
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' =>'',
  ),
      'vid' => array (
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' =>'',
  ),
      'biblio_type' => array (
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
        'description' =>'',
  ),
      'biblio_number' => array (
        'type' => 'varchar',
        'length' => '10',
        'description' =>'',
  ),
      'biblio_other_number' => array (
        'type' => 'varchar',
        'length' => '24',
        'description' =>'',
  ),
      'biblio_secondary_title' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_tertiary_title' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_edition' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_publisher' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_place_published' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_year' => array (
        'type' => 'int',
        'not null' => TRUE,
        'default' => 9999,
        'description' =>'',
  ),
      'biblio_volume' => array (
        'type' => 'varchar',
        'length' => '10',
        'description' =>'',
  ),
      'biblio_pages' => array (
        'type' => 'varchar',
        'length' => '128',
        'description' =>'',
  ),
      'biblio_date' => array (
        'type' => 'varchar',
        'length' => '16',
        'description' =>'',
  ),
      'biblio_isbn' => array (
        'type' => 'varchar',
        'length' => '24',
        'description' =>'',
  ),
      'biblio_lang' => array (
        'type' => 'varchar',
        'length' => '24',
        'default' => 'eng',
        'description' =>'',
  ),
      'biblio_abst_e' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_abst_f' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_full_text' => array (
        'type' => 'int',
        'default' => 0,
        'description' =>'',
  ),
      'biblio_keywords' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_url' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_issue' => array (
        'type' => 'varchar',
        'length' => '10',
        'description' =>'',
  ),
      'biblio_type_of_work' => array (
        'type' => 'varchar',
        'length' => '100',
        'description' =>'',
  ),
      'biblio_accession_number' => array (
        'type' => 'varchar',
        'length' => '30',
        'description' =>'',
  ),
      'biblio_call_number' => array (
        'type' => 'varchar',
        'length' => '30',
        'description' =>'',
  ),
      'biblio_notes' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom1' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom2' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom3' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom4' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom5' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom6' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_custom7' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_research_notes' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_number_of_volumes' => array (
        'type' => 'varchar',
        'length' => '10',
        'description' =>'',
  ),
      'biblio_short_title' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_alternate_title' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_original_publication' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_reprint_edition' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_translated_title' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_section' => array (
        'type' => 'varchar',
        'length' => '10',
        'description' =>'',
  ),
      'biblio_citekey' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_coins' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_doi' => array (
        'type' => 'varchar',
        'length' => '100',
        'description' =>'',
  ),
      'biblio_issn' => array (
        'type' => 'varchar',
        'length' => '24',
        'description' =>'',
  ),
      'biblio_auth_address' => array (
        'type' => 'text',
        'description' =>'',
  ),
      'biblio_remote_db_name' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_remote_db_provider' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_label' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_access_date' => array (
        'type' => 'varchar',
        'length' => '255',
        'description' =>'',
  ),
      'biblio_md5' => array (
        'type' => 'varchar',
        'length' => '32',
        'description' =>'',
  )
  ),
    'primary key' => array (
      'vid'
      ),
    'indexes' => array (
      'keywords' => array (
        'biblio_keywords'
        ),
      'nid' => array (
        'nid'
        ),
      'md5' => array (
        'biblio_md5'
        ),
      'year' => array (
        'biblio_year'
        )
        ),

        );

   $schema['biblio_fields'] = array(
    'fields' => array(
      'fid' => array(
        'type' => 'int',
        'not null' => TRUE,
          'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_fields}.fid of the node',
        ),
      'name' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => ''
        ),
      'type' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => 'textfield'
        ),
      'size' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 60,
        ),
      'maxsize' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 255,
        ),
        ),
      'primary key' => array('fid'),
        );

   $schema['biblio_field_type'] = array(
    'description' => 'Relational table linking {biblio_fields} with {biblio_field_type_data}',
    'fields' => array(
      'tid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_types}.tid of the node',
        ),
      'fid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_fields}.fid of the node',
        ),
      'ftdid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_field_type_data}.ftdid of the node, points to the current data, default or custom',
        ),
      'cust_tdid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'This always points to the custom data for this field. Stored so we can switch back an forth between default and custom',
        ),
      'common' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        ),
      'autocomplete' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        ),
      'required' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' => 'Is input required for this field'
        ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => FALSE,
        'default' => 0,
        'description' => 'The weight (location) of the field on the input form'
        ),
      'visible' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' => 'Determines if the field is visible on the input form'
        ),

        ),
    'primary key' => array('tid', 'fid'),
    'indexes' => array(
      'tid' => array('tid')
        ),
        );

   $schema['biblio_field_type_data'] = array(
    'description' => 'Data used to build the form elements on the input form',
    'fields' => array(
      'ftdid' => array(
        'type' => 'int',
        'not null' => TRUE,
          'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_field_type_data}.ftdid of the node',
        ),
      'title' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => '',
        'description' => 'The title, which will be displayed on the form, for a given field'
        ),
      'hint' => array(
        'type' => 'varchar',
        'length' => '255',
        'description' => 'The hint text printed below the input widget'
        ),
        ),
    'primary key' => array('ftdid'),
        );

        $schema['biblio_types'] = array(
    'fields' => array(
        'tid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => FALSE,
        'default' => 0,
        'description' =>'{biblio_types}.tid of the publication type',
        ),
      'name' => array(
        'type' => 'varchar',
        'length' => '64',
        'not null' => TRUE,
        'default' => '',
        'description' => 'The name of the publication type'
        ),
      'description' => array(
        'type' => 'varchar',
        'length' => '255',
        'description' => 'Description of the publication type'
        ),
      'weight' => array(
        'type' => 'int',
        'not null' => TRUE,
          'unsigned' => FALSE,
        'default' => 0,
        'description' => 'Controls the order the types are listed in'
        ),
      'visible' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 1,
        'description' => 'Determines if the publication type is visible in the list'
        ),
        ),
      'primary key' => array('tid'),

        );



 $schema['biblio_contributor'] = array(
  'description' => 'Relational table linking authors to biblio entries',
  'fields' => array(
      'nid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{node}.nid of the node',
        ),
      'vid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{node}.vid of the node',
        ),
        'cid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'{biblio_contributor_data}.cid of the node',
        ),
        'auth_type' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 1,
        'description' =>'{biblio_contributor_type}.auth_type of the node',
        ),
        'auth_category' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 1,
        'description' =>'',
        ),
        'rank' => array(
        'type' => 'int',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'default' => 0,
        'description' =>'Position of the author name on the publication (first,second,third...)',
        )
        ),
      'primary key' => array('vid', 'cid', 'auth_type', 'rank'),
        );

  $schema['biblio_contributor_data'] = array(
    'description' =>'Contains Author information for each publication',
    'fields' => array(
      'cid' => array(
        'type' => 'serial',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'description' =>'Primary Key: Author ID',
        ),
      'drupal_uid' => array(
        'type' => 'int',
        'not null' => FALSE,
        'unsigned' => TRUE,
        'description' =>'Drupal User ID',
        ),
        'name' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => '',
        'description' =>'Author last name',
        ),
      'lastname' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => '',
        'description' =>'Author last name',
        ),
      'firstname' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => FALSE,
        'default' => '',
        'description' =>'Author first name',
        ),
      'prefix' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => FALSE,
        'default' => '',
        'description' =>'Author name prefix',
        ),
      'suffix' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => FALSE,
        'default' => '',
        'description' =>'Author name suffix',
        ),
      'initials' => array(
        'type' => 'varchar',
        'length' => '10',
        'not null' => FALSE,
        'default' => '',
        'description' =>'Author initials (including first name initial)',
        ),
      'affiliation' => array(
        'type' => 'varchar',
        'length' => '255',
        'not null' => FALSE,
        'default' => '',
        'description' =>'Author affiliation or address',
        ),
      'md5' => array (
        'type' => 'varchar',
        'length' => '32',
        'description' =>'',
        )

        ),
      'primary key' => array('cid'),
      'indexes' => array(
          'lastname' => array('lastname'),
          'firstname' => array('firstname'),
          'initials' => array('initials')

        )
        );
    $schema['biblio_contributor_type'] = array(
      'description' =>'Contains definitions of the contributor types',
      'fields' => array(
        'auth_category' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' =>'There are 5 catagoies of author: Primary, Secondary, Tertiery, Subsidary and Corporate  ',
        ),
        'biblio_type' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' =>'',
        ),
        'auth_type' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' =>'This is the pulication type specific verion of a particular catagory',
        ),
        ),
    'primary key' => array('auth_category','biblio_type', 'auth_type'),

        );

  $schema['biblio_contributor_type_data'] = array(
    'description' => 'Data used to build the form elements on the input form',
    'fields' => array(
      'auth_type' => array(
        'type' => 'serial',
        'not null' => TRUE,
        'unsigned' => TRUE,
        'description' =>'{biblio_contributor_type_data} ctdid of the node',
        ),
      'title' => array(
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => '',
        'description' => 'The title, which will be displayed on the form, for a given field'
        ),
      'hint' => array(
        'type' => 'varchar',
        'length' => '255',
        'description' => 'The hint text printed below the input widget'
        ),
        ),
    'primary key' => array('auth_type'),
        );

    $schema['biblio_keyword'] = array(
      'description' => t('Relational table linking keywords to biblio nodes'),
      'fields' => array(
        'kid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The {biblio_keyword_data}.kid of the keyword of the node ')
        ),
        'nid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('The {node}.nid of the node.'),
        ),
        'vid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The {node}.vid of the node.'),
        ),
        ),
      'primary key' => array('kid', 'vid'),
      'indexes' => array(
           'vid' => array('vid'),
           'nid' => array('nid'),
        ),
        );

     $schema['biblio_keyword_data'] = array(
      'description' => t('Stores the keywords related to nodes.'),
      'fields' => array(
        'kid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The id of the keyword assigned to the node ')
        ),
        'word' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
          'description' => t('The keyword'),
        ),
        ),
      'primary key' => array('kid'),
      'indexes' => array(
           'kword' => array('word'),
        ),
        );
     $schema['biblio_collection'] = array(
      'description' => t('Relational table grouping biblio nodes into collections'),
      'fields' => array(
        'cid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The {biblio_collection_data}.cid of the collection')
        ),
        'vid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The {node}.vid of the node.'),
        ),
        'pid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('The parent id of the collection')
        ),
        'nid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('The {node}.nid of the node.'),
        ),
        ),
      'primary key' => array('cid','vid'),
      'indexes' => array(
           'pid' => array('pid'),
           'nid' => array('nid'),
        ),
        );
     $schema['biblio_collection_type'] = array(
      'description' => t('Descriptions of the collections.'),
      'fields' => array(
        'cid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The id of the collection ')
        ),
        'name' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
          'description' => t('The name of the collection'),
        ),
        'description' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
          'description' => t('The description of the collection'),
        ),
        ),
      'primary key' => array('cid'),
      'indexes' => array(
           'name' => array('name'),
        ),
        );
    $schema['biblio_duplicates'] = array(
      'description' => t('Relational table linking possible duplicate biblio nodes'),
      'fields' => array(
        'vid' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('Primary Key: The {biblio}.nid of the original node ')
        ),
        'did' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('The {biblio}.nid of the newly imported node which may be a duplicate.'),
        ),
        'type' => array(
          'type' => 'int',
          'not null' => TRUE,
          'unsigned' => TRUE,
          'default' => 0,
          'description' => t('The type of duplicate 0=biblio, 1=author.'),
        ),
        ),
      'primary key' => array('vid,did'),
        'indexes' => array(
           'did' => array('vid'),
        ),
        );

      $schema['biblio_import_cache'] = array(
        'description' => 'tables used for caching data imported from file and then batch processed',
        'fields' => array(
          'id' => array(
            'type'=>'serial',
            'not null' => TRUE,
            'unsigned' => TRUE),
          'session_id' => array(
            'type' => 'varchar',
            'length' => 45,
            'not null' => TRUE),
          'data' => array(
            'description' => t('A collection of data to cache.'),
            'type' => 'blob',
            'not null' => FALSE,
            'size' => 'big'),
        ),
        'primary key' => array('id'));
      
   return ($schema);

}

function biblio_reset_types(){
  $result = array();

  db_drop_table($result, 'biblio_field_type_data');
  db_drop_table($result, 'biblio_field_type');
  db_drop_table($result, 'biblio_fields');
  db_drop_table($result, 'biblio_contributor_type');
  db_drop_table($result, 'biblio_contributor_type_data');
  
  $schema = biblio_schema();
  db_create_table($result, 'biblio_field_type_data', $schema['biblio_field_type_data']);
  db_create_table($result, 'biblio_field_type', $schema['biblio_field_type']);
  db_create_table($result, 'biblio_fields', $schema['biblio_fields']);
  db_create_table($result, 'biblio_contributor_type', $schema['biblio_contributor_type']);
  db_create_table($result, 'biblio_contributor_type_data', $schema['biblio_contributor_type_data']);

  variable_set('biblio_last_ftdid', 100); // reset custom field type id too
  //_add_db_field_data_XML();
  _add_db_field_data();
  _add_custom_field_data();
}

function _add_publication_types()
{
  $types[] = array(-1,'Select Type...',NULL,-10);
  $types[] = array(100,'Book',NULL,1);
  $types[] = array(101,'Book Chapter',NULL,2);
  $types[] = array(102,'Journal Article',NULL,3);
  $types[] = array(103,'Conference Paper',NULL,4);
  $types[] = array(104,'Conference Proceedings',NULL,5);
  $types[] = array(105,'Newspaper Article',NULL,6);
  $types[] = array(106,'Magazine Article',NULL,7);
  $types[] = array(107,'Web Article',NULL,8);
  $types[] = array(108,'Thesis',NULL,9);
  $types[] = array(109,'Report',NULL,10);
  $types[] = array(110,'Film',NULL,11);
  $types[] = array(111,'Broadcast',NULL,12);
  $types[] = array(112,'Artwork',NULL,13);
  $types[] = array(113,'Software',NULL,14);
  $types[] = array(114,'Audiovisual',NULL,15);
  $types[] = array(115,'Hearing',NULL,16);
  $types[] = array(116,'Case',NULL,17);
  $types[] = array(117,'Bill',NULL,18);
  $types[] = array(118,'Statute',NULL,19);
  $types[] = array(119,'Patent',NULL,20);
  $types[] = array(120,'Personal',NULL,21);
  $types[] = array(121,'Manuscript',NULL,22);
  $types[] = array(122,'Map',NULL,23);
  $types[] = array(123,'Chart',NULL,24);
  $types[] = array(124,'Unpublished',NULL,25);
  $types[] = array(125,'Database',NULL,26);
  $types[] = array(126,'Government Report',NULL,27);
  $types[] = array(127,'Classical'	,NULL,28);
  $types[] = array(128,'Legal Ruling'	,NULL,29);
  $types[] = array(129,'Miscellaneous'	,NULL,30);
  $types[] = array(130,'Miscellaneous Section'	,NULL,31);

  foreach($types as $record)
  {
    $result[] = update_sql("INSERT INTO {biblio_types} (tid, name, description, weight) VALUES ('" . implode("', '", $record) . "')");
  }
 return $result;
}

function _add_db_field_data_XML() {
  $next_ctdid=10; //first contributor_type_data id
  $schema = biblio_schema();
  $fieldnames = array_keys($schema['biblio_fields']['fields']);
  $field_type_fieldnames = array_keys($schema['biblio_field_type']['fields']);
  $field_type_data_fieldnames = array_keys($schema['biblio_field_type_data']['fields']);
  db_query("/*!40000 ALTER TABLE {biblio_field_type_data} DISABLE KEYS */;");
  db_query("/*!40000 ALTER TABLE {biblio_fields} DISABLE KEYS */;");
  for ($type = 1; $type <= 5; $type++) {
    for ($biblio_type = 100; $biblio_type <= 130; $biblio_type++) {
      db_query("INSERT INTO {biblio_contributor_type} (auth_category, biblio_type, auth_type) VALUES (%d, %d, %d)",  $type, $biblio_type, $type);
    }
  }
//  db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", 1, "Author");
//  db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", 2, "Secondary Author");
//  db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", 3, "Tertiary Author ");
//  db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", 4, "Subsidiary Author ");
//  db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", 5, "Corporate Author ");
  _id_by_name(NULL, NULL, NULL, array('tablename' => 'biblio_field_type_data', 'name_column' => 'title', 'id_column' => 'ftdid'));
//  _id_by_name(NULL, NULL, NULL, array('tablename' => 'biblio_contributor_type_data', 'name_column' => 'title', 'id_column' => 'auth_type'));

  $xml_file = drupal_get_path('module', 'biblio') .'/field_data.xml';
  $xml = simplexml_load_file($xml_file);
  foreach($xml->field as $field){
    $link_data = array(0, $field['fid'], $field['fid'], $field['fid'], $field->common, $field->autocomplete, $field->required, $field->weight, $field->visible);
    db_query("INSERT INTO {biblio_field_type} (". implode(", ", $field_type_fieldnames) . ")
                  VALUES (%d, %d, %d, %d, %d, %d, %d, %d, %d)", $link_data);
    for ($t = 100; $t <= 130; $t++)
    {
      $values = array($t, $field['fid'], $field['fid'], $field['fid'], $field->common, $field->autocomplete, $field->required, $field->weight, $field->visible);
      db_query("INSERT INTO {biblio_field_type} (". implode(", ", $field_type_fieldnames) . ")
                      VALUES('" . implode("', '", $values) . "')");
    }
    $ftd = array($field['fid'], $field->default_name, $field->hint);
    db_query("INSERT INTO {biblio_field_type_data} (" . implode(", ", $field_type_data_fieldnames) . ")
                    VALUES('" . implode("', '", $ftd) . "')");
    $field_data = array($field['fid'], $field->field_name, $field->type, $field->width, $field->maxlength);
    db_query("INSERT INTO {biblio_fields} (" . implode(", ", $fieldnames) . ")
                    VALUES('" . implode("', '", $field_data) . "')");
    foreach ($field->name as $name){
      if ($name != "~" ) { //&& $field->type != 'contrib_widget') {
        $ftd[0] = ($existing_id = _id_by_name('biblio_field_type_data',$name)) ? $existing_id : variable_get('biblio_last_ftdid', 100); // ftdid
        $ftd[1] = trim($name);                          // title
        $ftd[2] = "";                                     // hint
        db_query("UPDATE {biblio_field_type}
                      SET ftdid = %d, cust_tdid = %d, visible = %d
                      WHERE tid = %d AND fid = %d ", $ftd[0], $ftd[0], 1, $name['tid'], $field['fid'] );
        if (!$existing_id){
          // if this title doesn't alreay exist, then insert it into the table
          db_query("INSERT INTO {biblio_field_type_data} (" . implode(", ", $field_type_data_fieldnames) . ")
                        VALUES (%d, '%s', '%s')", $ftd);
          _id_by_name('biblio_field_type_data',$name, $ftd[0]);  // cache the new id value for future use
          variable_set('biblio_last_ftdid', $ftd[0] +1); //increment the field type data id by one.
        }

      } elseif ($name == "~" ) {
        // turn the visibility off for this (~) type
        db_query("UPDATE {biblio_field_type}
                      SET visible = 0
                      WHERE tid = %d AND fid = %d ", $name['tid'], $field['fid'] );
      }
      if ($field->type == 'contrib_widget' && $name != "~" ) {
//        // also populate biblio_contributor_type tables
//        $title = trim($name);
//        if ($name != "~" ) {
//          // turn the visibility off for this (~) type
//          db_query("UPDATE {biblio_field_type}
//                      SET visible = 0
//                      WHERE tid = %d AND fid = %d ", $name['tid'], $field['fid'] );
//        }else {
//          $ctdid = ($eid = _id_by_name('biblio_field_type_data',$title)) ? $eid :  $next_ctdid;
          db_query("UPDATE {biblio_contributor_type} SET auth_type=%d where auth_category=%d and biblio_type=%d", $ftd[0], $field->contrib_type, $name['tid']);
//          if(!$eid) {
//            db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s')", $ctdid, $title);
//            _id_by_name('biblio_contributor_type_data',$title, $ctdid);  // cache the new id value for future use
//            $next_ctdid++;
//        }
//        }
      }
    }
  }



  db_query("/*!40000 ALTER TABLE {biblio_field_type_data} ENABLE KEYS */;");
  db_query("/*!40000 ALTER TABLE {biblio_fields} ENABLE KEYS */;");

  return $result;
}

function _add_db_field_data() {
  $schema = biblio_schema();
  $fieldnames = array_keys($schema['biblio_fields']['fields']);
  $field_type_fieldnames = array_keys($schema['biblio_field_type']['fields']);
  $field_type_data_fieldnames = array_keys($schema['biblio_field_type_data']['fields']);
  db_query("/*!40000 ALTER TABLE {biblio_field_type_data} DISABLE KEYS */;");
  db_query("/*!40000 ALTER TABLE {biblio_fields} DISABLE KEYS */;");

  $csv_file = drupal_get_path('module', 'biblio') .'/biblio.field.link.data.csv';

  if ($handle = fopen($csv_file, "r")){
    $header = fgetcsv($handle, 10000, ","); // the first line has the field names
    while (($row = fgetcsv($handle, 10000, ",")) !== FALSE) {
      $column = 0;
      // add link data for default biblio type (0) and all other defined types (100-130)
      foreach (array_merge(array(0), range(100,130)) as $t) {
        $link_data = array($t,$row[0],$row[0],$row[0],$row[3],$row[4],$row[5],$row[6],$row[7]);
        db_query("INSERT INTO {biblio_field_type} (". implode(", ", $field_type_fieldnames) . ")
                  VALUES ('" . implode("', '", $link_data) . "')");
      }
      $ftd = array($row[0],$row[1],$row[2]);
      db_query("INSERT INTO {biblio_field_type_data} (" . implode(", ", $field_type_data_fieldnames) . ")
                  VALUES('" . implode("', '", $ftd) . "')");
      $field_data = array($row[0],$row[8],$row[9],$row[10],$row[11]);
      db_query("INSERT INTO {biblio_fields} (" . implode(", ", $fieldnames) . ")
                  VALUES('" . implode("', '", $field_data) . "')");

      // add contributor type data
      if ($row[9] == 'contrib_widget') {
      	// use field name without trailing 's' as initial guess for author type
        $auth_type = (substr($row[1],-1,1) == 's') ? substr($row[1],0,-1) : $row[1];
        db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s' )", $row[0], $auth_type);
        db_query("INSERT INTO {biblio_contributor_type} (auth_category, biblio_type, auth_type) VALUES (%d, %d, %d)", $row[0], 0, $row[0]);
      }
    }
    fclose($handle);
    $result = array('success' => TRUE, 'query' => 'Added field titles and default values');

  } else {
    $result = array('success' => FALSE, 'query' => 'Could not open '.$csv_file);
  }


  db_query("/*!40000 ALTER TABLE {biblio_field_type_data} ENABLE KEYS */;");
  db_query("/*!40000 ALTER TABLE {biblio_fields} ENABLE KEYS */;");
  
  return $result;
}

function _add_custom_field_data() {

  $next_ctdid=10; //first contributor_type_data id
  $schema = biblio_schema();
  $fieldnames = array_keys($schema['biblio_field_type_data']['fields']);

  $query = "SELECT fid, name FROM {biblio_fields} ";
  $res = db_query($query);
  while ($row = db_fetch_object($res)){
    $fieldmap[$row->name] =  $row->fid;
  }

  $csv_file = drupal_get_path('module', 'biblio') .'/biblio.field.type.data.csv';
  
  if ($handle = fopen($csv_file, "r")){
    $header = fgetcsv($handle, 10000, ","); // the first line has the field names
    $generic = fgetcsv($handle, 10000, ","); // the second line has the default titles if none given
    // build cache lookups
    _id_by_name(NULL, NULL, NULL, array('tablename' => 'biblio_field_type_data', 'name_column' => 'title', 'id_column' => 'ftdid'));
    _id_by_name(NULL, NULL, NULL, array('tablename' => 'biblio_contributor_type_data', 'name_column' => 'title', 'id_column' => 'auth_type'));
    while (($row = fgetcsv($handle, 10000, ",")) !== FALSE) {
      $column = 0;
      if (empty($row[1])) continue;
      
      foreach ($header as $key => $field_name) {
        if (!empty($field_name) && $field_name != 'tid') {
          if (!empty($row[$column]) && $row[$column] != "~" && isset($fieldmap[$field_name])) {
       	    $ftd[0] = ($existing_id = _id_by_name('biblio_field_type_data',$row[$column])) ? $existing_id : variable_get('biblio_last_ftdid', 100); // ftdid
       	    $ftd[1] = trim($row[$column]);                          // title
       	    $ftd[2] = "";                                     // hint
       	    db_query("UPDATE {biblio_field_type}
                      SET ftdid = %d, cust_tdid = %d, visible = %d
                      WHERE tid = %d AND fid = %d ", $ftd[0], $ftd[0], 1, $row[1], $fieldmap[$field_name] );
       	    if (!$existing_id){
       	      // if this title doesn't alreay exist, then insert it into the table
       	      db_query("INSERT INTO {biblio_field_type_data} (" . implode(", ", $fieldnames) . ")
                        VALUES (%d, '%s', '%s')", $ftd);
              _id_by_name('biblio_field_type_data',$row[$column], $ftd[0]);  // cache the new id value for future use
              variable_set('biblio_last_ftdid', $ftd[0] +1); //increment the field type data id by one.
       	    }
       	    
       	    // also populate biblio_contributor_type tables
       	    if (strstr($field_name, 'contributors') && $row[$column] != '~' ) {
            switch ($field_name){
              case 'biblio_contributors2':
                $type = 2;
                break;
              case 'biblio_contributors3':
                $type = 3;
                break;
              case 'biblio_contributors4':
                $type = 4;
                break;
            }
            $title = trim($row[$column]);
            $biblio_type = $row[1];
            $ctdid = ($eid = _id_by_name('biblio_contributor_type_data',$title)) ? $eid :  $next_ctdid;
            db_query("UPDATE {biblio_contributor_type} SET auth_type=%d where auth_category=%d and biblio_type=%d", $ctdid, $type, $biblio_type);
            if(!$eid) {
              db_query("INSERT INTO {biblio_contributor_type_data} (auth_type, title) VALUES (%d, '%s')", $ctdid, $title);
              _id_by_name('biblio_contributor_type_data',$title, $ctdid);  // cache the new id value for future use
              $next_ctdid++;
            }
       	    }
          } elseif ($row[$column] == "~" && isset($fieldmap[$field_name])) {
            // turn the visibility off for this (~) type
            db_query("UPDATE {biblio_field_type}
                      SET visible = 0
                      WHERE tid = %d AND fid = %d ", $row[1], $fieldmap[$field_name] );
          } elseif (empty($row[$column]) && isset($fieldmap[$field_name])) {
            // use the default field title when the title is blank
            db_query("UPDATE {biblio_field_type}
                      SET visible = 1
                      WHERE tid = %d AND fid = %d ", $row[1], $fieldmap[$field_name] );
          }
        }
        $column++;
      }
    }
    fclose($handle);
    $result = array('success' => TRUE, 'query' => 'Added type specific field titles');
  } else {
    $result = array('success' => FALSE, 'query' => 'Could not open '.$csv_file);
  }

  return $result;
}
function _id_by_name($table, $name, $id = NULL, $build = NULL) {
  static $result = NULL;
  if (!empty($build)) { //refresh cache from table
    unset($result[$build['tablename']]);
    $res = db_query("SELECT ".$build['name_column'].", ".$build['id_column']." FROM {".$build['tablename']."}");
    while ($row = db_fetch_array($res)){
      $result[$build['tablename']][$row[$build['name_column']]] = $row[$build['id_column']];
    }
    return;
  }
  $name = trim($name);
  if (isset($result[$table][$name])) return $result[$table][$name];
  if ($id) $result[$table][$name] = $id;
  return FALSE;
}
/*
 * Removed updates 1 - 20 since they dated back to ver. 5-1.2
 */

function biblio_update_21(){
  $result = array();

  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_doi` varchar(100) default NULL;");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_issn` varchar(24) default NULL;");
  $result[] = update_sql("INSERT INTO {biblio_fields} (`fid`,`name`,`title`,`common`,`type`,`size`,`maxsize`,`hint`,`required`,`visible`,`autocomplete`,`weight`) VALUES
                        (45,'biblio_issn','ISSN Number',1,'textfield',24,24,'',0,0,0,150),
                        (46,'biblio_doi','DOI',1,'textfield',60,255,'',0,0,0,159);");
  $result[] = update_sql("UPDATE {biblio_fields}  SET  title = 'ISBN Number' WHERE name = 'biblio_isbn';");
  return $result;
}

function biblio_update_22() {
  $result = array();

  $result[] = update_sql("alter table {biblio} modify `biblio_custom1` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom2` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom3` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom4` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom5` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom6` text ;");
  $result[] = update_sql("alter table {biblio} modify `biblio_custom7` text ;");
  $result[] = update_sql("UPDATE {biblio_fields}  SET  type = 'textarea',size=60,maxsize=65535 WHERE name LIKE 'biblio_custom%';");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_auth_address` text ;");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_remote_db_name` varchar(255) default NULL;");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_remote_db_provider` varchar(255) default NULL;");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_label` varchar(255) default NULL;");
  $result[] = update_sql("ALTER TABLE {biblio}  ADD  `biblio_access_date` varchar(255) default NULL;");
  $result[] = update_sql("INSERT INTO {biblio_fields} (`fid`,`name`,`title`,`common`,`type`,`size`,`maxsize`,`hint`,`required`,`visible`,`autocomplete`,`weight`) VALUES
                        (47,'biblio_auth_address','Author Address',0,'textarea',60,65535,'',0,0,0,178),
                        (48,'biblio_remote_db_name','Remote Database Name',0,'textfield',60,255,'',0,0,0,176),
                        (49,'biblio_remote_db_provider','Remote Database Provider',0,'textfield',60,255,'',0,0,0,177),
                        (50,'biblio_label','Label',0,'textfield',60,255,'',0,0,0,178),
                        (51,'biblio_access_date','Access Date',0,'textfield',60,255,'',0,0,0,179)
                        ;");

  return $result;

}

function biblio_update_23() {
  $result = array();

  $result[] = update_sql("UPDATE {biblio}  SET  biblio_year = 9999 WHERE biblio_year = 0 ;");

  return $result;

}

function biblio_update_24() {
  $result = array();

  $result[] = update_sql("UPDATE {biblio}  SET  biblio_year = 9998 WHERE biblio_year = 1 ;");
  $result[] = update_sql("UPDATE {biblio_fields} SET size = 9 WHERE name = 'biblio_year';");
  $result[] = update_sql("UPDATE {biblio_fields} SET maxsize = 9 WHERE name = 'biblio_year';");

  return $result;

}

function biblio_update_25() {
  $result = array();

  $result[] = update_sql("UPDATE {biblio_fields} SET hint = '(YYYY, In Press or Submitted)' WHERE name = 'biblio_year';");

  return $result;
}

function biblio_update_26() {
  $result = array();

  $result[] = update_sql("UPDATE {biblio}  SET  biblio_year = 9997 WHERE biblio_year = 9999 ;");
  $result[] = update_sql("UPDATE {biblio}  SET  biblio_year = 9999 WHERE biblio_year = 9998 ;");
  $result[] = update_sql("UPDATE {biblio}  SET  biblio_year = 9998 WHERE biblio_year = 9997 ;");
  $result[] = update_sql("UPDATE {biblio_fields} SET hint = '(Submitted, In Press or YYYY)' WHERE name = 'biblio_year';");

  return $result;
}

function biblio_update_27(){
  $result = array();

  $result[] = update_sql("ALTER TABLE {biblio_fields}  MODIFY hint varchar(255);");

  return $result;
}


function _move_field_data(&$result)
{
  $schema = biblio_schema();

  // update default settings in biblio_field_type from old biblio_fields
  $result[] = update_sql("UPDATE {biblio_field_type} ft, {biblio_field_type_data} ftd
		/* augment by old biblio_fields matching fields based on title instead of fid due to shift in fids */
		INNER JOIN {biblio_fields_old} fo ON fo.title=ftd.title
		SET ftd.hint=fo.hint, ft.common=fo.common, ft.autocomplete=fo.autocomplete, ft.required=fo.required, ft.weight=fo.weight, ft.visible=fo.visible
		WHERE ft.ftdid=ftd.ftdid AND ft.ftdid<>1");
  
  // add new field types from old biblio_type_details
  $db_result = db_query("SELECT old.*,f.fid as fidnew FROM 
		/* biblio_type_details augmented by field name (biblio_*) */
		(SELECT otd.*,fo.name FROM {biblio_type_details} otd 
		 INNER JOIN {biblio_fields_old} fo ON otd.fid=fo.fid) old 
		/* left join: all entries from biblio_type_details are matched to existing entries in biblio_field_type_data */
		LEFT JOIN {biblio_field_type_data} ftd ON old.title=ftd.title 
		/* add matching fids (fidnew) from new biblio_fields based on field name */
		INNER JOIN {biblio_fields} f ON f.name=old.name
		/* consider only those entries in biblio_type_details which have no match in biblio_field_type_data */
		WHERE ftd.title IS NULL");
  while ($row = db_fetch_array($db_result))
  {
    // check for presence of this field_type
    $fieldtype = db_fetch_array(db_query("SELECT * FROM {biblio_field_type_data} WHERE title='".$row['title']."'"));
    if(!is_array($fieldtype)) {
      $new_ftdid = variable_get('biblio_last_ftdid',100);
      variable_set('biblio_last_ftdid',$new_ftdid + 1);
      $fieldtype = array('ftdid' => $new_ftdid, 'title' => $row['title'], 'hint' => $row['hint']);
      drupal_write_record('biblio_field_type_data',$fieldtype);
    }
    // update ftdid in linking table to new field type
    $ftdid=$fieldtype['ftdid'];
    $result[] = update_sql("UPDATE {biblio_field_type} SET ftdid=$ftdid, cust_tdid=$ftdid WHERE tid={$row['tid']} AND fid={$row['fidnew']}");
  }

  // update biblio_field_type (linking table) with overrides from old biblio_type_details
  $result[] = update_sql("UPDATE {biblio_field_type} ft 
		INNER JOIN {biblio_field_type_data} ftd ON ft.ftdid=ftd.ftdid 
		/* link to old biblio_type_details based on field title and publication type */
		INNER JOIN {biblio_type_details} otd ON otd.title=ftd.title AND otd.tid=ft.tid
		SET ft.required=otd.required, ft.weight=otd.weight");
  // update auth_type associated to (auth_category,biblio_type) from old biblio_type_details
  $result[] = update_sql("UPDATE {biblio_contributor_type} ct
		INNER JOIN 
			/* select contributor fields from biblio_type_details (fid <= 4) and augment with new ctd.auth_type */
			(SELECT tid,IF(fid=4,5,fid) AS auth_category,ctd.auth_type FROM {biblio_type_details} b 
 			 INNER JOIN {biblio_contributor_type_data} ctd ON b.title=ctd.title WHERE b.fid <= 4) otd 
			/* match on publication type and auth_category, fid=4 (corp. author) changed to catagory 5 */
			ON otd.tid=ct.biblio_type AND otd.auth_category=ct.auth_category
		SET ct.auth_type=otd.auth_type");

  return $result;
}
/**
 * This function generates md5 hashes for all the biblio entries in the
 * database. These hashes are used to detect potential duplicate entries 
 * when adding or importing. 
 * 
 * @return a result array for the update process
 */
function biblio_md5_generate()
{
  $res = db_query("SELECT n.nid,n.vid, n.title, b.biblio_year, cd.lastname
                   FROM {node} n INNER JOIN {biblio} b ON n.vid = b.vid
                   INNER JOIN {biblio_contributor} c ON c.vid = b.vid
                   INNER JOIN {biblio_contributor_data} cd ON cd.cid = c.cid
                   WHERE c.rank = 0 AND c.auth_type = 1 AND n.type = 'biblio' ");
  $count=0;
  while ($node = db_fetch_object($res)) {
    $hash_string = str_replace(' ', '', drupal_strtolower($node->title));
    $hash_string .= str_replace(' ', '', drupal_strtolower($node->lastname));
    $hash_string .= $node->biblio_year;

    $md5 = md5($hash_string);

    db_query("UPDATE {biblio} SET biblio_md5 = '$md5' WHERE vid = $node->vid");
    $count++;
  }
  return array('success' => TRUE, 'query' => "Generated checksums for $count nodes");
}

/**
 * This parses the old (pre 6.x) format author entry, splits in on 
 * the semicolons and adds new elements to the biblio_contributors array
 * @param $biblio_contributors an array passed in by reference 
 * @param $authors    The old author string
 * @param $type   The type of author (Primary, Secondary, Tertiary, Corporate)
 * @return none ($biblio_contributors is passed in by reference) 
 */
function _parse_authors(&$biblio_contributors, $authors, $cat = 1)
{
  $authors = str_ireplace(" and ", "; ", $authors); 
  $authors = str_ireplace(" & ", "; ", $authors); 
  $author_array = explode(';', $authors);
  foreach($author_array as $author)
  {
    // insert spaces after firstname initials if neccessary
    $author = preg_replace("/\.([^\s-])/", ". \\1", trim($author));
    $biblio_contributors[$cat][] = array('name' => $author, 'auth_type' => $cat);
  }
}

function _move_authors(&$result)
{
  drupal_get_schema('biblio_contributor_data', TRUE);
  // this update will move author information from existing biblio table to the new
  // biblio_contributor_data table and make the appropriate links in the biblio_contributor table
  require_once(drupal_get_path('module', 'biblio') . '/biblio.contributors.inc');
  $res = db_query("SELECT nid,vid,biblio_authors, biblio_secondary_authors,biblio_tertiary_authors,biblio_corp_author FROM {biblio}  ");
  $count=0; $count_success=0;
  while ($biblio = db_fetch_array($res)) {
    $biblio_contributors = array();
    if (!empty($biblio['biblio_authors'])) _parse_authors($biblio_contributors, $biblio['biblio_authors'], 1);
    if (!empty($biblio['biblio_secondary_authors'])) _parse_authors($biblio_contributors, $biblio['biblio_secondary_authors'], 2);
    if (!empty($biblio['biblio_tertiary_authors'])) _parse_authors($biblio_contributors, $biblio['biblio_tertiary_authors'], 3);
    if (!empty($biblio['biblio_corp_author'])) _parse_authors($biblio_contributors, $biblio['biblio_corp_author'], 5);
    $biblio_contributors = biblio_parse_contributors($biblio_contributors);
    if (_save_contributors($biblio_contributors, $biblio['nid'], $biblio['vid'])) $count_success++;
    $count++;
  }
  // change auth_type to match overrides set in old biblio_type_details
  update_sql("UPDATE {biblio_contributor} c 
		/* augment by biblio_type from biblio */
		INNER JOIN {biblio} b ON c.nid=b.nid AND c.vid=b.vid
		/* augment by old config settings */ 
		INNER JOIN 
			(SELECT tid,if(fid=4,5,fid) as auth_type,title FROM
				/* select (tid,fid) specific titles from 5.x: biblio_fields_old contains the defaults, biblio_type_details the overrides */
				(SELECT tid,fid,title FROM {biblio_type_details} WHERE fid<=4
				 UNION SELECT tid,fid,title FROM {biblio_fields_old}, {biblio_types} WHERE fid<=4 AND tid>=100) t
			 /* grouping by tid,fid removes the duplicate default title if an override is available */
			 GROUP BY tid,fid) otd 
		/* match old config (otd) and newly imported (with type 1,2,3,5 see above) on biblio_type and auth_type */
		ON otd.tid=b.biblio_type AND otd.auth_type=c.auth_type
		/* augment with new auth_type based on title */
		INNER JOIN {biblio_contributor_type_data} ctd ON ctd.title=otd.title
		/* update auth_type in biblio_contributor table */
		SET c.auth_type=ctd.auth_type");

  $result[] = array('success' => ($count_success == $count), 
                    'query' => 'Moved authors from '.$count_success.' / '.$count.' publications to the new database stucture');

  return $result;
}

function biblio_update_6000()
{
  $result = array();
  $schema = biblio_schema();
  // modifications to biblio main table
  db_add_field($result, 'biblio', 'biblio_md5', array('type' => 'varchar', 'length' => '32') );
  db_add_index($result, 'biblio', 'md5', array('biblio_md5'));
  $result[] = update_sql("ALTER TABLE {biblio} MODIFY biblio_year int NOT NULL DEFAULT '9999' ");
  $result[] = update_sql("ALTER TABLE {biblio}  MODIFY biblio_citekey varchar(255) ");

  // create new tables
  $result[] = update_sql("ALTER TABLE {biblio_fields} RENAME TO {biblio_fields_old}");
  db_drop_table($result, 'biblio_author_index');
  db_drop_table($result, 'biblio_has_author');
  db_create_table($result, 'biblio_fields',$schema['biblio_fields']);
  db_create_table($result, 'biblio_field_type',$schema['biblio_field_type']);
  db_create_table($result, 'biblio_field_type_data',$schema['biblio_field_type_data']);
  db_create_table($result, 'biblio_contributor',$schema['biblio_contributor']);
  db_create_table($result, 'biblio_contributor_data',$schema['biblio_contributor_data']);
  db_create_table($result, 'biblio_contributor_type',$schema['biblio_contributor_type']);
  db_create_table($result, 'biblio_contributor_type_data',$schema['biblio_contributor_type_data']);
  db_create_table($result, 'biblio_keyword',$schema['biblio_keyword']);
  db_create_table($result, 'biblio_keyword_data',$schema['biblio_keyword_data']);
  db_create_table($result, 'biblio_collection',$schema['biblio_collection']);
  db_create_table($result, 'biblio_collection_type',$schema['biblio_collection_type']);
  db_create_table($result, 'biblio_duplicates',$schema['biblio_duplicates']);

  // fill biblio_field* tables with defaults
  $result[] = _add_db_field_data();
  $result[] = _add_custom_field_data();

  // move data
  _move_field_data($result);
  _move_authors($result);

  db_drop_table($result, 'biblio_fields_old');
  db_drop_table($result, 'biblio_type_details');

  $result[] = biblio_md5_generate();
  return $result;
} 

function biblio_update_6011(){
  $result = array();
  $schema = biblio_schema();
  if (!db_table_exists('biblio_import_cache')){
    db_create_table($result, 'biblio_import_cache',$schema['biblio_import_cache']);
  }
  return $result;
}
function biblio_update_6012(){
  $result = array();
  $result[] = _add_biblio_keywords();
  return $result;
}

function biblio_update_6013() {
  $result = array();
  if (!db_column_exists('biblio_contributor', 'auth_category')) { // we don't need to do this if upgrading from 5.x
    db_add_field($result, 'biblio_contributor', 'auth_category',
    array('type' => 'int', 'not null' => TRUE, 'unsigned' => TRUE, 'default' => 1));
    $result[] = update_sql("UPDATE {biblio} b
                          INNER JOIN {biblio_contributor} bc on b.vid = bc.vid
                          LEFT JOIN  {biblio_contributor_type} bct on b.biblio_type = bct.biblio_type and bct.auth_type = bc.auth_type
                          SET bc.auth_category=bct.auth_catagory");
    $result[] = update_sql("ALTER TABLE {biblio_contributor_type} CHANGE COLUMN auth_catagory auth_category INTEGER UNSIGNED NOT NULL DEFAULT 0,
                          DROP PRIMARY KEY,
                          ADD PRIMARY KEY USING BTREE(auth_category, biblio_type, auth_type)");
  }
  $result[] = update_sql("UPDATE {biblio_fields} SET maxsize=20 WHERE name='biblio_year'");

  return $result;
}
