<?php
/**
 *   biblio.module for Drupal
 *
 *   Copyright (C) 2006-2011  Ron Jerome
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this program; if not, write to the Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/**
 * Implements hook_access().
 */
function biblio_access($op, $node = '') {
  global $user;

  switch ($op) {
    case 'admin':
      return user_access('administer biblio');
    case 'import':
      return user_access('import from file');
    case 'export':
      return user_access('show export links');
    case 'edit_author':
        if (user_access('administer biblio') || user_access('edit biblio authors')) return NODE_ACCESS_ALLOW;
        break;
    case 'download':
      if (user_access('show download links') || (user_access('show own download links') && ($user->uid == $node->uid))) return NODE_ACCESS_ALLOW;
      break;
    case 'rss':
      return variable_get('biblio_rss', 0);
    default:
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_permission().
 *
 * Since we are limiting the ability to create new nodes to certain users,
 * we need to define what those permissions are here. We also define a permission
 * to allow users to edit the nodes they created.
 */
function biblio_permission() {
  return array(
    'administer biblio' => array(
      'title' => t('Administer Biblio'),
      'description' => t('Allows full control (create, update, delete) of all Biblio nodes'),
    ),
    'access biblio content' => array(
      'title' => t('Access Biblio content'),
      'description' => t('Allows the user to view Biblio nodes'),
    ),
   'create biblio' => array(
     'title' => t('Create Biblio'),
     'description' => t('Allows the user to create new Biblios'),
   ),
   'edit all biblio entries' => array(
     'title' => t('Edit all Biblio entries'),
     'description' => t('Allows the user to edit ALL biblio entries regardless of who "owns" them, otherwise they are restricted to on'),
   ),
    'delete biblios' => array(
      'title' => t('Delete Biblios'),
      'description' => t('Allows the user to delete any biblio entities'),
    ),
    'edit by all biblio authors' => array(
      'title' => t('Edit by all Biblio authors'),
      'description' => t('Allows any/all of the authors associated with a biblio entry to edit the biblio entry. This requires the Drupal UserID be mapped to a Biblio author ID'),
    ),
    'edit biblio authors' => array(
      'title' => t('Edit Biblio authors'),
      'description' => t('Allows the user to edit author information'),
    ),
    'manage biblio structure' => array(
      'title' => t('Manage Biblio structure'),
      'description' => t('This determines if the user will be able to modify field and display settings for biblio and contributor entities (admin/structure/biblio)'),
    ),
    'manage biblio content' => array(
      'title' => t('Manage Biblio content'),
      'description' => t('This determines if the user will be able to access the managment interface for biblios and contributors (admin/content/biblio)'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function biblio_menu() {
  $items = array();
  $base = 'biblio';
  $base_title = 'Biblio';

  // Main Biblio Content
  //----------------------------------------------------------------------------
  $items[$base] = array(
    'title'             => $base_title,
    'page callback'     => 'biblio_page',
    'access callback'   => 'user_access',
    'access arguments'  => array('access biblio content'),
    'file'              => '/includes/biblio.pages.inc',
  );
  $items[$base . "/%biblio"] = array(
    'title callback' => 'biblio_page_title',
    'title arguments' => array(1),
    'page callback' => 'biblio_page_view',
    'page arguments' => array(1),
    'access arguments' => array('access biblio content'),
    'type' => MENU_CALLBACK,
  );
  $items[$base . "/%biblio/view"] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'access arguments' => array('access biblio content')
  );
  $items[$base . "/%biblio/edit"] = array(
    'title' => 'Edit',
    'page callback' => 'biblio_page_edit',
    'page arguments' => array(1),
    'access arguments' => array('edit all biblio entries'),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/biblio.admin.inc',
  );
  $items[$base . "/%biblio/delete"] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblio_delete_confirm', 1),
    'access arguments' => array('edit all biblio entries'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/biblio.admin.inc',
  );
  $items[$base . "/contributor/%biblio_contributor"] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('biblio_contributor', 2), //callback
    'page callback' => 'biblio_contributor_page_view', //callback
    'page arguments' => array(2),
    'access arguments' => array('access biblio content'),
  );
  $items[$base . "/contributor/%biblio_contributor/view"] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'access arguments' => array('access biblio content'),
  );
  $items[$base . "/contributor/%biblio_contributor/edit"] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblio_contributor_form', 2),
    'access arguments' => array('edit all biblio entries'),
    'file' => 'includes/biblio.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );
  $items[$base . "/contributor/%biblio_contributor/delete"] = array(
    'title' => 'Delete Contributor',
    'title callback' => 'biblio_contributor_label',
    'title arguments' => array(2),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblio_contributor_delete_confirm', 2),
    'access arguments' => array('edit all biblio entries'),
  );

  // Biblio Structure Management
  // ---------------------------------------------------------------------------
  $items["admin/structure/biblio"] = array(
    'title' => 'Biblio',
    'description' => 'Manage Fields and Dislplay for Biblios and Contributors',
    'access arguments' => array('administer biblio'),
    'page callback' => 'biblio_overview_types',
    'page arguments' => array('biblio'),
    'file' => 'includes/biblio.admin.inc',
    'access arguments' => array('manage biblio structure'),
  );
  $items["admin/structure/biblio/publication-types"] = array(
    'title' => 'Publication Types',
    'description' => 'Manage Biblio Publication Types',
    'access arguments' => array('manage biblio structure'),
    'weight' => 0,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items["admin/structure/biblio/contributors"] = array(
    'title' => 'Contributors',
    'description' => 'Manage Biblio Contributor Fields/Display',
    'page callback'     => 'biblio_overview_types',
    'page arguments'    => array('biblio_contributor'),
    'file'              => '/includes/biblio.admin.inc',
    'access arguments' => array('manage biblio structure'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // Biblio Settings
  //----------------------------------------------------------------------------
  $items['admin/config/content/biblio'] = array(
    'title'             => 'Biblio settings',
    'description'       => 'Configure default behavior of the Biblio module.',
    'page callback'     => 'drupal_get_form',
    'page arguments'    => array('biblio_admin_settings'),
    'access arguments'  => array('administer biblio'),
    'file'              => '/includes/biblio.admin.inc',
  );

  return $items;
}

/**
 * Removes brace from a string
 *
 * @param string $title_string
 * @return string
 */
function biblio_remove_brace($title_string) {
    //$title_string = utf8_encode($title_string);
    $matchpattern = '/\{\$(?:(?!\$\}).)*\$\}|(\{[^}]*\})/';
    $output = preg_replace_callback($matchpattern, 'biblio_remove_brace_callback', $title_string);
    return $output;
}

/**
 * Callback from preg_replace_callback
 *
 * @param array $match
 * @return array
 */
function biblio_remove_brace_callback($match) {
  if (isset($match[1])) {
    $braceless = str_replace('{', '', $match[1]);
    $braceless = str_replace('}', '', $braceless);
    return $braceless;
  }
  return $match[0];
}

/**
 * Displays the Add/Edit form for a biblio entity
 *
 * @global object $user
 * @param array $form
 * @param array $form_state
 * @param object $biblio
 * @return array
 */
function biblio_form($form, &$form_state, $biblio = NULL) {
  global $user;
  $fields = array();

  $form['#id'] = 'biblio-form';

  // Check to see if we've imported a biblio object using a sub-module
  if (isset($form_state['biblio_imported'])) {
    $biblio = $form_state['biblio_imported'];
  }
  $form['biblio_tabs'] = $tabs = array();

  $publication_type = !empty($form_state['biblio_type']) ?
      $form_state['biblio_type'] :
      ( isset($biblio->publication_type) ? $biblio->publication_type : '');
  if (isset($_COOKIE['has_js']) && !$_COOKIE['has_js']) {
    unset($form['biblio_next']['#attributes']);
  }

  $step_two = FALSE;
  if ((!empty($publication_type) && $publication_type != 'select_type')
   || isset($biblio)) {
    $step_two = TRUE;
  }

  /* publication type */
  $param['options'] = array("enctype" => "multipart/form-data");
  foreach (biblio_types() as $machine_name => $info) {
    $type_options[$machine_name] = $info->name;
  }
  asort($type_options);
  $options['select_type'] = t('Select Type...');
  $options += $type_options;


  if (!$step_two) {
    $form['biblio_type'] = array(
      '#type' => 'select',
      '#title' => t('Publication Type'),
      '#default_value' =>  $publication_type,
      '#options' => $options,
      '#description' => NULL,
      '#weight' => -15,
      '#attributes' =>  array('onchange' => 'document.getElementById(\'edit-biblio-next\').click();
        document.getElementById(\'edit-biblio-next\').disabled="true"'),
      '#multiple' => FALSE,
      '#required' => TRUE
    );

    $form['biblio_next'] = array(
        '#type'   => 'submit',
        '#value'  => $step_two ? t('Change Publication Type') : t('Next'),
        '#limit_validation_errors' => array(),
        '#weight' => -10,
        '#submit' => array(),
    );
  }
  else {
    // Step two
    module_load_include('inc', 'biblio', 'includes/biblio.fields');

    // Add field instances only if they dont already exist.
    if (biblio_field_instances_missing($publication_type)) {
      biblio_add_field_instances('biblio', $publication_type);
    }

    // Create a new, empty biblio object
    if (!isset($biblio)) {
      $biblio = biblio_create($publication_type);
    }
    $wrapper = biblio_wrapper($biblio);

    // Set the title. PASS_TRHOUGH allows us to include HTML in the string.
    drupal_set_title(t('Create @name', array('@name' => $options[$publication_type])), PASS_THROUGH);

    $instance_info = field_info_instances('biblio', $biblio->publication_type);

    // $fielded_form becomes a placeholder for form values that are automatically
    // returned to us from the Field Attach API
    $fielded_form = $form;
    field_attach_form('biblio', $biblio, $fielded_form, $form_state);

    $tabs = array(
      '#type' => 'vertical_tabs',
      '#weight' => 3,
    );
    $tabs += biblio_form_vtabs();

    $tabs['contributors'] += biblio_contributor_widget($biblio, $form_state);

    // Add imported keywords as the default value for the biblio_keywords field
    if (isset($form_state['biblio_imported']) && isset($fielded_form['biblio_keywords'])) {
      $langcode = $fielded_form['biblio_keywords']['#language'];
      $fielded_form['biblio_keywords'][$langcode]['#default_value'] =
        implode(', ', $biblio->biblio_keywords);
    }

    // Add the values we created above to the real form
    foreach ($fielded_form as $field => $data) {
      // Set a vtab value, if it exists (not all array keys are valid fields)
      $vtab = (isset($instance_info[$field]['settings']['vtab']))?
        $instance_info[$field]['settings']['vtab'] : FALSE;
      // We don't want extra theme elements from $fielded_form.
      // Just field instances with a set vtab.
      if ($vtab !== FALSE) {
        if ($vtab == 'none' || $vtab == 'None') {
          // Fields specified to be outside of the vtabs
          $form[$field] = $data;
        }
        else {
          // Add all other fields to the vtabs
          $tabs[$vtab][$field] = $data;
        }
      }
      // No vtab specified. Includes user-created fields
      else {
        if (biblio_is_field_instance($field, 'biblio', $biblio->publication_type)) {
          $form[$field] = $data;
        }
      }
    }

    $form_state['biblio_fields'] = $fields;

    foreach (element_children($tabs) as $key) {
      $tab_children = element_children($tabs[$key]);
      if (empty($tab_children) && $key != 'biblio_full_text') {
        unset($tabs[$key]);
      }
    }
    // Add the buttons.
    // Save button is always available
    $form['buttons'] = array();
    $form['buttons']['#weight'] = 100;
    $form['buttons']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Save'),
      '#weight' => 5,
      '#submit' => array('biblio_form_submit'),
    );
    // Delete button is available if we're editing an existing biblio.
    if (!empty($biblio->bid)) {
      $form['buttons']['delete'] = array(
        '#access' => user_access('delete biblios'),
        '#type' => 'submit',
        '#value' => t('Delete'),
        '#weight' => 15,
        '#submit' => array('biblio_form_delete_submit'),
      );
    }

    $form_state['biblio'] = $biblio;
  }

  // $form['format'] = filter_form($node->format, 20);
 //$biblio_form['#tree']  = TRUE;
  $form['#validate']= array('biblio_form_validate');
  $form['#cache'] = TRUE;
  $form['biblio_tabs'] += $tabs;

  biblio_hide_form_fields($form, $form_state);

  return $form;
}

/**
 * Creates the vertical tab form structure as used in the add/edit form
 *
 * @return array
 */
function biblio_form_vtabs() {
  $vtabs = biblio_form_vtab_info();

  foreach ($vtabs as $tab) {
    $form[$tab['tab_id']] = array(
        '#type' => 'fieldset',
        '#group' => 'biblio_tabs',
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
        '#title' => t($tab['title']),
        '#description' => '',
        '#weight' => $tab['weight']
    );
  }
  return $form;
}

/**
 * Get info specific to each vertical tab
 *
 * @return array
 */
function biblio_form_vtab_info() {
  return array(
    array('tab_id' => 'contributors', 'weight' => 9, 'title' => 'Contributors', 'description' => 'Enter a single name per line using a format such as "Smith, John K" or "John K Smith" or "J.K. Smith"'),
    array('tab_id' => 'abstract', 'weight' => 10, 'title' => 'Abstract', 'description' => ''),
    array('tab_id' => 'full_text', 'weight' => 11, 'title' => 'Full text', 'description' => ''),
    array('tab_id' => 'publication', 'weight' => 12, 'title' => 'Publication', 'description' => ''),
    array('tab_id' => 'publisher', 'weight' => 13, 'title' => 'Publisher', 'description' => ''),
    array('tab_id' => 'identifiers', 'weight' => 14, 'title' => 'Identifiers', 'description' => ''),
    array('tab_id' => 'locators', 'weight' => 15, 'title' => 'Locators', 'description' => 'URL\'s etc'),
    array('tab_id' => 'keywords', 'weight' => 16, 'title' => 'Keywords', 'description' => ''),
    array('tab_id' => 'notes', 'weight' => 17, 'title' => 'Notes', 'description' => ''),
    array('tab_id' => 'alternate_titles', 'weight' => 18, 'title' => 'Alternate Titles', 'description' => ''),
    array('tab_id' => 'other', 'weight' => 19, 'title' => 'Other', 'description' => ''),
    );
}

/**
 * Set up the form for ONE contributor in the biblio add/edit form.
 *
 * @param object $contributor
 * @param array $form_state
 * @param integer $delta The iterative value of the current contributor. 0,1,2...etc.
 * @return string
 */
function biblio_contributor_biblio_form($contributor, $biblio, &$form_state) {
  module_load_include('inc', 'biblio', 'includes/biblio.contributors');
  foreach (biblio_contributor_categories($biblio->publication_type)
    as $category => $info) {
    $category_options[$category] = $info['label'];
  }
  $form = array('#tree' => TRUE);

  $form['name'] = array(
    '#type' => 'textfield',
    '#autocomplete_path' =>  'biblio/autocomplete/contributor',
    '#default_value' => isset($contributor['name']) ? $contributor['name'] : '',
  );
  $form['category'] = array(
    '#type' => 'select',
    '#default_value' => isset($contributor['category']) ? $contributor['category'] : '',
    '#options' => $category_options,
    '#multiple' => FALSE,
  );
  $form['cid'] = array(
    '#type' => 'hidden',
    '#default_value' => isset($contributor['cid']) ? $contributor['cid'] : '',
  );
  $form['rank'] = array(
    '#type' => 'textfield',
    '#size' => 6,
    '#default_value' => isset($contributor['rank']) ? $contributor['rank'] : '',
   );
  // Get the language of the name field
  // $lang = $form['biblio_contributor_name']['#language'];
  // Set up autocomplete for the Name field
  // $form['biblio_contributor_name'][$lang][0]['value']['#autocomplete_path']
    // = 'biblio/autocomplete/contributor';
  // Set the form's parents so FAPI can distinguish between the multiple Name fields
  // $form['#parents'] = array(
  //   'biblio_tabs',
  //   1,
  //   'biblio_contributors',
  //   $delta,
  //   'biblio_contributor_name'
  // );
  // // Remove the title above each field
  // $form['biblio_contributor_name'][$lang][0]['value']['#title'] = '';
  // // Reset the language to the language set for biblio_contributor_category field
  // $lang = $form['biblio_contributor_category']['#language'];
  // // Remove the "- None -" option from the select list
  // unset($form['biblio_contributor_category'][$lang]['#options']['_none']);
  // // Remove the title above each field
  // $form['biblio_contributor_category'][$lang]['#title'] = '';
  return $form;
}

function biblio_hide_form_fields(&$form, &$form_state) {
  module_load_include('inc', 'biblio', 'includes/biblio.contributors');
  $elements_to_hide = array();
  $biblio = (isset($form_state['biblio'])) ? $form_state['biblio'] : FALSE;

  if ($biblio) {
    $instances = field_info_instances('biblio', $biblio->publication_type);

    // Hide all entity reference widgets, so we can make use of the default biblio
    // contributor widget
    foreach (biblio_contributor_categories() as $category => $info) {
      $vtab = $instances[$info['field']]['settings']['vtab'];
      $elements_to_hide[$vtab][] = $info['field'];
    }
  }

  // Set all containers of form fields we want to hide, to hidden
  foreach($elements_to_hide as $vtab => $fields) {
    foreach($fields as $field) {
      // Fields with a biblio vtab set
      if (isset($form['biblio_tabs'][$vtab][$field])) {
        $form['biblio_tabs'][$vtab][$field]['#type'] = 'hidden';
      }
      // Fields that aren't in a biblio vtab
      else if (isset($form[$field])) {
        $form[$field]['#type'] = 'hidden';
      }
    }
  }
}


/**
 * Implements hook_ctools_plugin_api().
 */
function biblio_ctools_plugin_api($module, $api) {
  if ($module == 'biblio' && $api == 'biblio_style') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function biblio_ctools_plugin_type() {
  $plugins['biblio_style'] = array(
    'classes' => array('class'),
    'process' => 'biblio_plugin_process',
  );
  return $plugins;
}


/**
 * Add defaults values to the notifier plugins.
 *
 * - 'description': The description of the plugin.
 */
function biblio_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function biblio_ctools_plugin_directory($module, $plugin) {
  if ($module == 'biblio') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Helper function to include CTools plugins and get a notifier plguin.
 *
 * @param $plugin_name
 *   The plugin that should be laoded.
 */
function biblio_get_biblio_style($style_name) {
  ctools_include('plugins');
  return ctools_get_plugins('biblio', 'biblio_style', $style_name);
}

/**
 * Helper function to include CTools plugins and get all notifier plugins.
 */
function biblio_get_biblio_styles() {
  ctools_include('plugins');
  return ctools_get_plugins('biblio', 'biblio_style');
}

/**
 * Helper function to return all notifiers as options for a select list.
 */
function biblio_get_notifiers_as_options() {
  $options = array();
  foreach (biblio_get_biblio_styles() as $style_name => $style) {
    $options[$style_name] = check_plain($style['title']);
  }

  return $options;
}

/**
 * Implements hook_views_api().
 */
function biblio_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'biblio') . '/views',
  );
}
/**
 * Implements hook_entity_info().
 *
 * Inform the Drupal and the Field API about entity types.
 * Uses the contrib Entity API module to create entities
 */
function biblio_entity_info() {
  $return['biblio'] = array(
    'label' => t('Biblio'),
    'entity class' => 'Biblio',
    'controller class' => 'EntityAPIController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'biblio',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'bid',
      'bundle' => biblio_bundle_name('biblio'),
    ),
    'bundle keys' => array(
      'bundle' => biblio_bundle_name('biblio'),
    ),
    'bundles' => array(),
    'load hook' => 'biblio_load',
    'view modes' => array(),
    // Entity API label callback that takes a look at our entity class method defaultLabel()
    'label callback' => 'entity_class_label',
    // This is also a standard Entity API callback for uri.
    // It executes our entity defaultUri() method
    'uri callback' => 'entity_class_uri',
    'module' => 'biblio',
    'access callback' => 'biblio_entity_access',
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  if (db_table_exists('biblio')) {
    $biblio_types = db_select('biblio', 'b')
      ->fields('b')
      ->execute()
      ->fetchAllAssoc('type');
  }

  if (!empty($biblio_types)) {
    foreach ($biblio_types as $type => $info) {
      $return['biblio']['bundles'][$type] = array(
        'label' => $info->name,
        'admin' => array(
          // defines the path that should be used in hook_menu() for the Fields UI pages
          'path' => 'admin/structure/biblio/publication-types/%biblio_bundle',
          // The exact path that should be used when generating links within the admin interface
          'real path' => 'admin/structure/biblio/publication-types/' . str_replace('_', '-', $type),
          // menu args are 0 based, so  is the seventh part of the path, which
          // here is %biblio_bundle.
          'bundle argument' => 4,
          'access arguments' => array('manage biblio structure'),
        ),
      );
    }
  }

  $return['biblio_contributor'] = array(
    'label' => t('Contributor'),
    'entity class' => 'BiblioContributor',
    'controller class' => 'BiblioContributorController',
    'base table' => 'biblio_contributor',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'cid',
      'bundle' => biblio_bundle_name('biblio_contributor'),
      'label' => 'title',
    ),
    'bundle keys' => array(
      'bundle' => biblio_bundle_name('biblio_contributor'),
    ),
    // @todo: possibly figure out a better bundle name and/or figure out what
    // bundles we can have for contributors
    'bundles' => array(),
    'load hook' => 'biblio_contributor_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'biblio',
    'access callback' => 'biblio_entity_access',
  );


  return $return;
}

/**
 * Gets all publication types that are set up by default.
 * @return type
 *
 * @todo: Fix.
 */
function biblio_types($entity_type = FALSE) {
  return;
    $query = db_select('biblio', 'bt')
        ->fields('bt', array('name', 'description', 'entity'));

    if ($entity_type) {
      $query->condition('entity', $entity_type);
    }

    $result = $query->execute();

    $entity_type_passed_in = $entity_type;
    while ($row = $result->fetchAssoc()) {
      if ($entity_type_passed_in === FALSE) {
        $entity_type = $row['entity'];
      }
      $bundle_name = biblio_bundle_name($entity_type);
      // computer-friendly version of the human-readable content type stored in the database
      $machine_name = str_replace(' ', '_', strtolower($row['name']));

      $types[$machine_name] = (object)array(
        // type is the machine name of the bundle
        $bundle_name => $machine_name,
        'entity' => $row['entity'],
        // name is the human name of the bundle
        'name' => t($row['name']),
        'description' => t($row['description']),
      );

    }

  return $types;
}

/**
 * Gets the title of a bundle for a given entity type
 *
 * @param string $entity_type
 * @return string
 */
function biblio_bundle_name($entity_type) {
  switch ($entity_type) {
    case 'biblio':
      return 'publication_type';
      break;
    default:
      return 'type';
      break;
  }
}

/**
 * Access callback for the entity API.
 */
function biblio_entity_access($op, $type = NULL, $account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('administer biblio', $account)
          || user_access('create biblio', $account);
    case 'view':
      return user_access('administer biblio', $account)
          || user_access('access biblio content', $account);
    case 'delete':
    case 'edit':
      return user_access('administer biblio')
          || user_access('edit all biblio entries');
  }
}

function biblio_bundle_load($type) {
  return biblio_combined_bundle_load($type);
}

function contributor_bundle_load($type) {
  return biblio_combined_bundle_load($type);
}

/**
 * Get an individual publication type definition object.
 * Necessary for the %biblio_bundle menu placeholder to work in hook_menu().
 *
 * @param type $type
 *  The key of the publication type we want
 * @return object
 *  The specified publication type.
 */
function biblio_combined_bundle_load($type) {
  foreach (biblio_entities() as $entity) {
    foreach (biblio_types($entity) as $type_name => $info) {
      $types[$type_name] = $info;
    }
  }
  // Replace dashes in a type name with underscores.
  // All Drupal paths use dashes in place of underscores in the URI, but
  // bundle names need to use underscores, not dashes.
  $type = str_replace('-', '_', $type);
  return isset($types[$type]) ? $types[$type] : FALSE;
}

/**
 * Very simply returns an array of all the entity types that biblio creates.
 *
 * @return array Iterative array containing the biblio entity types
 */
function biblio_entities() {
  return array('biblio', 'biblio_contributor');
}

/**
 * Create a biblio entity object
 *
 * @param $type
 *  The publication type of the biblio to be created (bundle)
 * @param array $values
 *  An associative array of any additional values to be set when creating this
 *  entity. These values will be carried throughout the biblio object's life.
 *  Example: $values['language'] => 'en';
 * @return object The biblio object, with default values.
 */
function biblio_create($type, $values = array()) {
  $values['type'] = $type;
  return entity_create('biblio', $values);
}

/**
 * Load a biblio object from the database.
 *
 * @param $bid
 *   The biblio ID.
 * @param $reset
 *   Whether to reset the biblio_load_multiple cache.
 *
 * @return
 *   A fully-populated node object.
 */
function biblio_load($bid, $reset = FALSE) {
  $biblios = biblio_load_multiple(array($bid), array(), $reset);
  $biblio = reset($biblios);

  return $biblio;
}

/**
 * Load biblio entities from the database.
 *
 * This function should be used whenever you need to load more than one biblio
 * from the database. biblios are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see entity_load()
 *
 * @param $bids
 *   An array of biblio IDs.
 * @param $conditions
 *   An array of conditions on the {biblio} table in the form 'field' => $value.
 * @param $reset
 *   Whether to reset the internal entity_load cache.
 *
 * @return
 *   An array of biblio objects indexed by bid.
 */
function biblio_load_multiple($bids = array(), $conditions = array(), $reset = FALSE) {
  // entity_load() will create a new instance of biblioController as needed
  // and call the load() method on it.
  $biblios = entity_load('biblio', $bids, $conditions, $reset);
  return $biblios;
}

/**
 * Let the Form API validate our form for us.
 *
 * @param array $form
 * @param array $form_state
 */
function biblio_form_validate($form, &$form_state) {
  if ($form_state['triggering_element']['#value'] == t('Next')
   || $form_state['triggering_element']['#value'] == t('Change Publication Type')) {
    $form_state['rebuild'] = TRUE;
    $form_state['biblio_type'] = $form_state['values']['biblio_type'];
    if ($form_state['values']['biblio_type'] == '') {
      form_set_error('biblio_type', t('Please select a publication type.'));
    }
    return;
  }

  if (isset($form_state['biblio']) && !isset($biblio)) {
    $biblio = $form_state['biblio'];
  }
  if (isset($biblio)) {
    // Field validation.
    $i = 0;
    field_attach_form_validate('biblio', $biblio, $form, $form_state);
  }
}

/**
 * Process data that was submitted from the biblio add form. This handles the
 * additions of Biblio and Contributor entities.
 *
 * @global type $user
 * @param type $form
 * @param array $form_state
 */
function biblio_form_submit($form, &$form_state) {
  global $user;
  module_load_include('inc', 'biblio', 'includes/biblio.contributors');

  // Pull the old biblio object out of the $form_state variable.
  $biblio = &$form_state['biblio'];

  // Set the biblio's uid if it's being created at this time.
  if (empty($biblio->uid)) {
    $biblio->uid = $user->uid;
  }

  biblio_create_contributor_refs($form_state);

  // Notify field widgets.
  field_attach_submit('biblio', $biblio, $form, $form_state);

  // Save the biblio.
  biblio_save($biblio);

  // Notify the user.
  drupal_set_message(t('Biblio saved.'));

  $form_state['redirect'] = 'biblio/' . $biblio->bid;
}


/**
 * hook_menu() callback
 */
function biblio_page_title($biblio) {
  $wrapper = biblio_wrapper($biblio);
  return $wrapper->biblio_title->value();
}

/**
 * Rather than build a complete form, we will simply pass data on to a utility
 * function of the Form API called confirm_form().
 *
 * @param type $form
 * @param type $form_state
 * @param type $biblio
 * @return type
 */
function biblio_delete_confirm($form, &$form_state, $biblio) {
  $wrapper = biblio_wrapper($biblio);
  $form['#biblio'] = $biblio;
  // Always provide entity id in the same form key as in the entity edit form
  $form['bid'] = array('#type' => 'value', '#value' => $biblio->bid);
  return confirm_form($form,
    t('Are you sure you want to delete %title?', array('%title' => $wrapper->biblio_title->value())),
    'biblio/' . $biblio->bid,
    t('This action cannot be undone.'),
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Delete form confirmation page
 *
 * @param array $form
 * @param array $form_state
 */
function biblio_delete_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $wrapper = biblio_wrapper($form['#biblio']);
    biblio_delete($form['#biblio']);
    watchdog('biblio', '@type: deleted %title.',
      array(
        '@type' => $wrapper->publication_type,
        '%title' => $wrapper->biblio_title->value(),
      )
    );

    $types = biblio_types('biblio');
    drupal_set_message(t('@type %title has been deleted.',
        array(
          '@type' => $types[$wrapper->publication_type->value()]-> name,
          '%title' => $wrapper->biblio_title->value(),
        )
    ));
  }

  $form_state['redirect'] = '<front>';
}

/**
 * Redirects the user to biblio/$bid/delete
 *
 * @param type $form
 * @param type $form_state
 */
function biblio_form_delete_submit($form, &$form_state) {
  $destination = array();
  if (isset($_GET['destination'])) {
    $destination = drupal_get_destination();
    unset($_GET['destination']);
  }
  $biblio = $form_state['biblio'];
  $form_state['redirect'] = array('biblio/' . $biblio->bid . '/delete',
      array('query' => $destination));
}

/**
 * Create a contributor entity object
 * @param  string $name   (optional) The name of the contributor. If given, this
 *                        function will parse out the author name and
 *                        automatically fill in any associated fields (first
 *                        name, last name, initials, etc.) and the type
 * @param  string $type   (optional) The contributor type (bundle) of the
 *                        contributor entity to create. ex: 'person' or
 *                        'organization'. Leave null to let this function parse
 *                        the name (if passed in) and auto-generate the type.
 * @param  array  $values (optional)
 * @return object         The contributor entity object
 */
function biblio_contributor_create($name = NULL, $type = NULL, $values = array()) {
}

/**
 * Load a contributor.
 */
function biblio_contributor_load($cid, $reset = FALSE) {
  $contributors = biblio_contributor_load_multiple(array($cid), array(), $reset);
  return reset($contributors);
}

/**
 * Load multiple contributors based on certain conditions.
 */
function biblio_contributor_load_multiple($cids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('biblio_contributor', $cids, $conditions, $reset);
}

/**
 * Displays a biblio contributor; Hands data off to the Field API
 *
 * @param type $contributor
 * @param type $view_mode View mode defined in biblio_entity_info().
 * @return type
 */
function biblio_contributor_page_view($contributor, $view_mode = 'full') {
  // Remove previously built content, if exists.
  $contributor->content = array();
  $wrapper = biblio_wrapper($contributor, 'biblio_contributor');
  // Build fields content. Standard stuff.
  field_attach_prepare_view('biblio_contributor', array($contributor->cid => $contributor), $view_mode);
  entity_prepare_view('biblio_contributor', array($contributor->cid => $contributor));
  $contributor->content += field_attach_view('biblio_contributor', $contributor, $view_mode);
  $extra_fields = field_extra_fields_get_display(
    'biblio_contributor', 'contributor', $view_mode);
  // $contributor->content = array_merge($extra_fields, $contributor->content);
  biblio_append_extra_fields($contributor->content, $extra_fields);
  if (isset($contributor->content['view_all_by_contributor'])) {
    $contributor->content['view_all_by_contributor']['#markup'] =
      l(t('View all publications by ' . $wrapper->biblio_contributor_name->value()),
        'biblio/contributor/' . $contributor->cid . '/publications', array(
          'attributes' => array(
            'class' => array('biblio-view-all-by-contrib')
            )
          )
        );
  }

  return $contributor->content;
}

function biblio_append_extra_fields(&$content, $extra_fields) {
  foreach($extra_fields as $field => $info){
    if (isset($info['visible']) && $info['visible']) {
      $content[$field] = array();
      foreach ($info as $attribute => $value) {
        $content[$field]['#' . $attribute] = $value;
      }
    }
  }
}

/**
 * hook_menu callback function for admin/structure/biblio/add
 *
 * @return string
 */
function biblio_add() {
  return drupal_get_form('biblio_form');
}

/**
 * Presents the biblio editing form, or redirects to delete confirmation.
 *
 * @param type $biblio
 * @return type
 */
function biblio_page_edit($biblio) {
  $wrapper = biblio_wrapper($biblio);
  $lang = biblio_field_language('biblio_title', $biblio);
  $types = biblio_types('biblio');

  drupal_set_title(t('<em>Edit @type</em> @title', array('@type' =>
    $types[$biblio->publication_type]->name, '@title' =>$wrapper->biblio_title->value())), PASS_THROUGH);

  return drupal_get_form('biblio_form', $biblio);
}

/**
 * hook_menu callback function for biblio/add/[publication-type]
 *
 * @global type $user
 * @param type $type
 * @return array
 */
function biblio_contributor_add() {
  // Create a new, empty biblio contributor object
  $contributor = entity_create('biblio_contributor', array());
  // Set page title
  // PASS_TRHOUGH as the second param tells the function to allow HTML in the
  // string we're giving because we've already checked to make sure it's safe.
  drupal_set_title(t('Create Contributor'), PASS_THROUGH);

  // Display the form
  return drupal_get_form('biblio_contributor_add_form', $contributor);
}

/**
 * Build the contributor add form
 * Called by the Form API
 *
 * @param array $form
 * @param array $form_state
 * @param object $contributor
 * @return type
 */
function biblio_contributor_add_form($form, &$form_state, $contributor) {

  // Save the biblio for later, in case we need it.
  $form['#contributor'] = $contributor;
  $form_state['contributor'] = $contributor;

  // Get all fields from the Field API
  field_attach_form('biblio_contributor', $contributor, $form, $form_state);

  // Add autocomplete to name field
  foreach ($form['field_author_name']['und'] as $key => $field_data) {
    if (is_numeric($key)) {
      $form['field_author_name']['und'][$key]['value']['#autocomplete_path'] = 'biblio/autocomplete/contributor';
    }
  }

  // Add the buttons.
  // Save button is always available
  $form['buttons'] = array();
  $form['buttons']['#weight'] = 100;
  $form['buttons']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 5,
    '#submit' => array('biblio_contributor_form_submit'),
  );
  // Delete button is available if we're editing an existing biblio.
  if (!empty($contributor->cid)) {
    $form['buttons']['delete'] = array(
      '#access' => user_access('delete biblios'),
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#weight' => 15,
      '#submit' => array('biblio_contributor_form_delete_submit'),
    );
  }
  return $form;
}

/**
 * Glue code between the form and the biblio_contributor_save() function.
 *
 * @global type $user
 * @param type $form
 * @param array $form_state
 */
function biblio_contributor_form_submit($form, &$form_state) {
  global $user;

  // Pull the old biblio object out of the $form_state variable.
  $contributor = &$form_state['contributor'];

  // Set the biblio's uid if it's being created at this time.
  if (empty($contributor->uid)) {
    $contributor->uid = $user->uid;
  }
  // Notify field widgets.
  field_attach_submit('biblio_contributor', $contributor, $form, $form_state);
  // Save the contributor.
  biblio_contributor_save($contributor);

  // Notify the user.
  drupal_set_message(t('Contributor saved.'));

  $form_state['redirect'] = 'biblio/contributor/' . $contributor->cid;
}

function biblio_contributor_form($form, $form_state, $contributor = NULL) {
  field_attach_form('biblio_contributor', $contributor, $form, $form_state);
  $form_state['contributor'] = $contributor;
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 50,
    '#submit' => array('biblio_contributor_form_submit'),
  );
  // Delete button is available if we're editing an existing biblio.
  if (!empty($contributor->cid)) {
    $form['delete'] = array(
      '#access' => user_access('delete biblios'),
      '#type' => 'submit',
      '#value' => t('Delete'),
      '#weight' => 51,
      '#submit' => array('biblio_contributor_form_delete_submit'),
    );
  }
  return $form;
}

function biblio_contributor_form_delete_submit($form, &$form_state) {
  $destination = array();
  if (isset($_GET['destination'])) {
    $destination = drupal_get_destination();
    unset($_GET['destination']);
  }
  $contributor = $form_state['contributor'];
  $form_state['redirect'] = array('biblio/contributor/' . $contributor->cid . '/delete',
      array('query' => $destination));
}

/**
 * Rather than build a complete form, we will simply pass data on to a utility
 * function of the Form API called confirm_form().
 *
 * @param type $form
 * @param type $form_state
 * @param type $biblio
 * @return type
 */
function biblio_contributor_delete_confirm($form, &$form_state, $contributor) {
  $form['#contributor'] = $contributor;
  // Always provide entity id in the same form key as in the entity edit form
  $form['cid'] = array('#type' => 'value', '#value' => $contributor->cid);
  return confirm_form($form,
    t('Are you sure you want to delete %title?', array('%title' => $contributor->title)),
    'biblio/contributor/' . $contributor->cid,
    t('This action cannot be undone.'),
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Delete form confirmation page
 *
 * @param array $form
 * @param array $form_state
 */
function biblio_contributor_delete_confirm_submit($form, &$form_state) {
  if ($form_state['values']['confirm']) {
    $contributor = $form['#contributor'];
    biblio_contributor_delete($contributor);
    watchdog('biblio', 'Deleted biblio contributor %title.',
      array(
        '%title' => $contributor->title,
      )
    );

    drupal_set_message(t('Contributor %title has been deleted.',
        array(
          '%title' => $contributor->title,
        )
    ));
  }

  $form_state['redirect'] = '<front>';
}

/**
 * Implements hook_admin_paths().
 */
function biblio_admin_paths() {
  $base = variable_get('biblio_base', 'biblio');
  $paths = array(
    "$base/*/edit" => TRUE,
    "$base/*/delete" => TRUE,
  );
  return $paths;
}

/**
 * hook_menu callback for biblio administration pages that display a View.
 *
 * @param string $view_name The machine name of the view to show
 * @param string $view_display The display ID of the view to show
 *
 * @return type
 */
function biblio_admin_view($view_name, $view_display) {
  if (!module_exists('views')) {
    drupal_set_message('This page requires the Views module be enabled.', 'error');
    return;
  }

  $view_obj = views_get_view($view_name);
  // If the view exists
  if ($view_obj) {
    return views_page($view_name, $view_display);
  }
  else {
    $message = "Could not locate the <i>" . $view_name . "</i> View using the display <i>" . $view_display . "</i>. Please ensure that the Views module is enabled, and that the <i>" . $view_name . "</i> View is enabled.";
    drupal_set_message($message, 'error');
  }

  return '';
}

/**
 * Implements hook_form_alter().
 */
function biblio_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['#field']['bundles']['biblio'])) {
    switch ($form_id) {
      // Modify the Field settings form so we can add an option to select vtab
      // for a field in the biblio add/edit form
      case 'field_ui_field_settings_form':
      case 'field_ui_field_edit_form':
        $field_name = $form['#instance']['field_name'];
        $entity_type = $form['#instance']['entity_type'];
        $bundle = $form['#instance']['bundle'];
        $field_info = field_info_instance($entity_type, $field_name, $bundle);
        if (isset($field_info['settings']['vtab'])) {
          $vtab_default_value = $field_info['settings']['vtab'];
        }
        else {
          $vtab_default_value = 'none';
        }
        $vtabs = biblio_form_vtab_info();

        foreach($vtabs as $vtab_info) {
          $options[$vtab_info['tab_id']] = t($vtab_info['title']);
        }
        $options['none'] = t('None');

        $form['instance']['settings']['vtab'] = array(
          '#type' => 'select',
          '#title' => t('Biblio Form Vertical Tab'),
          '#options' => $options,
          '#default_value' => $vtab_default_value,
          '#required' => TRUE,
        );
        break;
    }
  }
}
/**
 * Implements hook_entity_property_info_alter().
 */
function biblio_entity_property_info_alter(&$info) {
  $properties = &$info['biblio']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the biblio was added."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'description' => t("The date the biblio was most recently changed/edited."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'changed',
  );
  $properties['uid'] = array(
    'label' => t("Author"),
    'type' => 'user',
    'description' => t("The creator of the biblio entity."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'required' => TRUE,
    'schema field' => 'uid',
  );
  $properties['biblio_sort_title'] = array(
    'label' => t("Sort Title"),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'biblio_sort_title',
  );

  $properties = &$info['biblio_contributor']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the contribtuor was added."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'description' => t("The date the contributor was most recently changed/edited."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'changed',
  );
  $properties['md5'] = array(
    'label' => t("MD5"),
    'description' => t("MD5 of the contributor. Used for resolving duplicates"),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'md5',
  );
}
