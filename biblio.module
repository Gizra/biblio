<?php
// $Id$ 
/** 
 *   biblio.module for Drupal
 *    
 *   Copyright (C) 2006-2008  Ron Jerome
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this program; if not, write to the Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */  
 
function biblio_theme() {

  return array(
    'biblio_form_types_edit' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('form'),
    ),
    'biblio_add_css' => array(
      'file' => 'biblio_theme.inc',
    ),
    'biblio_coin_button' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('element'),
    ),
    'biblio_openurl' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('openURL'),
    ),
    'biblio_export_links' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('nid'),
    ),
    'biblio_short' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('node', 'base' => 'biblio', 'style_name' => 'classic', 'inline' => FALSE),
    ),
    'biblio_long' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('node', 'base' => 'biblio', 'style_name' => 'classic'),
    ),
    'biblio_tabular' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('node', 'base' => 'biblio', 'teaser' => FALSE),
    ),
    'biblio_list' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('node', 'base' => 'biblio', 'style_name' => 'classic', 'inline' => FALSE),
    ),
    'biblio_filters' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('form'),
    ),
    'form_filter' => array(
      'file' => 'biblio_theme.inc',
      'arguments' => array('form'),
    ),
  );
} 
function biblio_autocomplete($field, $string='') {
    $matches = array();
    $result = db_query_range("SELECT $field FROM {biblio} WHERE LOWER($field) LIKE LOWER('%s%%') ORDER BY $field ASC", $string, 0, 10);
    while ($data = db_fetch_object($result)) {
      $matches[$data->$field] = check_plain($data->$field);
    }
    print drupal_to_js($matches);
    exit();
}
function biblio_help_page() {
  $base =  variable_get('biblio_base', 'biblio');
  
  $text .= "<h3>". t('General:') ."</h3>";
  $text .= "<p>". t('By default, the !url page will list all of the entries in the database sorted by Year in descending order. If you wish to sort by "Title" or "Type",  you may do so by clicking on the appropriate links at the top of the page.  To reverse the sort order, simply click the link a second time.', array('!url' => l('', $base))) ."</p>";
  $text .= "<h3>". t('Filtering Search Results:') ."</h3>";
  $text .= "<p>" . t('If you wish to filter the results, click on the "Filter" tab at the top of the page.  To add a filter, click the radio button to the left of the filter type you wish to apply, then select the filter criteria from the drop down list on the right, then click the filter button.') ."</p>";
  $text .= "<p>" . t('It is possible to create complex filters by returning to the <i>Filter</i> tab and adding additional filters.  Simply follow the steps outlined above and press the "Refine" button.') ."</p>";
  $text .= "<p>". t('All filters can be removed by clicking the <i>Clear All Filters</i> link at the top of the result page, or on the <i>Filter</i> tab they can be removed one at a time using the <i>Undo</i> button, or you can remove them all using the <i>Clear All</i> button.') ."</p>";
  $text .= "<p>". t('You may also construct URLs which filter.  For example, /biblio/year/2005 will show all of the entries for 2005.  /biblio/year/2005/author/smith will show all of entries from 2005 for smith.') ."</p>";
  $text .= "<h3>". t('Exporting Search Results:') ."</h3>";
  $text .= "<p>". t('Assuming this option has been enabled by the administrator, you can export search results directly into EndNote.  The link at the top of the result page will export all of the search results, and the links on individual entries will export the information related to that single entry.') ."</p>";
  $text .= "<p>". t('The information is exported in EndNote "Tagged" format similar to this...') .
              "<pre>". t('
              %0  Book
              %A  John Smith 
              %D  1959
              %T  The Works of John Smith
              ...') .'
              </pre></p>';
  $text .= "<p>". t('Clicking on one of the export links should cause your browser to ask you whether you want to Open, or Save To Disk, the file endnote.enw.  If you choose to open it, Endnote should start and ask you which library you would like store the results in.  Alternatively, you can save the file to disk and manually import it into EndNote.') ."</p>";

  return  ($text);
} 

/**
* Implementation of hook_help().
* 
* Throughout Drupal, hook_help() is used to display help text at the top of
* pages. Some other parts of Drupal pages get explanatory text from these hooks
* as well. We use it here to provide a description of the module on the
* module administration page.
*/

function biblio_help($path, $arg) {
  switch ($path) {
    case 'admin/help#biblio':
      return biblio_help_page();

    case 'admin/modules#description': 
      // This description is shown in the listing at admin/modules.
      return t('Manages a list of scholarly papers on your site');
    case 'node/add#biblio': 
      // This description shows up when users click "create content."
      return t('This allows you to add a bibliographic entry to the database');
  } 
} 

function biblio_node_info() {
  return array('biblio' => array(
                    'name' => t('biblio'), 
                    'module' => 'biblio',
                    'description' => t('Maintains list of bibliographies')));
}


/**
* Implementation of hook_access().
* 
* Node modules may implement node_access() to determine the operations
* users may perform on nodes. This example uses a very common access pattern.
*/
function biblio_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create biblio');
  } 
  if ($op == 'import') {
    // Only users with permission to do so may import entries from file.
    return user_access('import from file');
  } 
  if ($op == 'export') {
    // Only users with permission to do so may export entries from file.
    return user_access('show export links');
  } 
  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if ( user_access('edit own biblio entries') && ($user->uid == $node->uid)) {
      return true;
    }
    else if  (user_access('edit all biblio entries')) {
      return true;
    }
    else{
      return false;
    } 
  }
  if ($op == 'view') {
    if (variable_get('biblio_view_only_own', 0) ) {
       if (  $user->uid == $node->uid ) {
         return true;
       }
       else{
         return false;
       }
    }
    else{
       return true;
    }
  } 
} 

/**
* Implementation of hook_perm().
* 
* Since we are limiting the ability to create new nodes to certain users,
* we need to define what those permissions are here. We also define a permission
* to allow users to edit the nodes they created.
*/
function biblio_perm() {
  return array('create biblio', 'edit all biblio entries', 'edit own biblio entries', 'import from file', 'show export links', 'show filter tab', 'show sort links', 'view full text');
} 
/**
* Implementation of hook_link().
* 
* This is implemented so that an edit link is displayed for users who have
* the rights to edit a node.
*/
function biblio_link($type, $node = NULL, $teaser = FALSE) {
   $links = array();
 
   if ($type == 'node' && $node->type == 'biblio') {
     // Don't display a redundant edit link if they are node administrators.
     if (biblio_access('update', $node) && !user_access('administer nodes')) {
       $links['biblio_edit'] = array(
          'title' => t('edit this entry'),
          'href' => "node/$node->nid/edit",
        );
        return $links;
     }
  } 
  return;
} 
/**
 * Implementation of hook_user().
 */
function biblio_user($type, &$edit, &$user, $category = NULL) {
  if ($type == 'view' && (( isset($user->biblio_show_profile) ) ? $user->biblio_show_profile : variable_get('biblio_show_profile', '0'))) {
    $user->content['biblio'] = array(
      '#title' => t('My publications'),
      '#type' => 'user_profile_category',
      '#value' => _biblio_get_user_pubs($user,'profile') ,
      '#attributes' => array('class' => 'biblio'),
    );
    $user->content['biblio']['pubs'] = array(
      '#title' => '',
      '#value' => _biblio_get_user_pubs($user,'profile') ,
      '#attributes' => array('class' => 'biblio'),
    );
  }
  
  if ($type == 'form' && $category == 'account') {
    $form = array();
    include_once  drupal_get_path('module','biblio') . '/biblio.admin.inc';
     _biblio_get_user_profile_form($form, $user);
    return $form;
  }

  if ($type == 'validate' && $category == 'account') {
  //  return _user_edit_validate(arg(1), $edit);
  }

  if ($type == 'after_update' && $category == 'account') {
    menu_rebuild();
  }

  if ($type == 'categories') {
  //  return array(array('name' => 'account', 'title' => t('Account settings'), 'weight' => 1));
  }
}

/**
* Implementation of hook_menu().
* 
* Here we define some built in links for the biblio module, links exposed are:
*   /node/add/biblio      => to add a single entry
*   /biblio               => lists all entries in the biblio database
*   /biblio/list          => default local task for /biblio
*   /biblio/filter        => local task which allows users to add filters to their query
*   /biblio/filter/clear  => used internally to remove all filters
*   /biblio/help          => displays a help page
*   /biblio/export/endnote => used to export information in Endnote Tagged format
*   /biblio/import/form   => presents a form to allow the user to upload a file to import
*    
*   
*/
function biblio_menu() {
  global $user;
  $items = array();

  $base =  variable_get('biblio_base', 'biblio');

  $items["$base"] = array(
    'title' => '',
    'page callback' => 'biblio_db_search',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  if ($user->uid  && ( (isset($user->biblio_my_pubs_menu) ) ? $user->biblio_my_pubs_menu : variable_get('biblio_my_pubs_menu', '0')) ) {
    $items["$base/user"] = array(
      'title' => 'My publications',
      'page callback' => '_biblio_get_user_pubs',
      'page arguments' => array($user),
      'parent' => '',
    );
  }
    // The next two "LOCAL TASKS" are for the admin/settings/biblio page  
  $items['admin/settings/biblio'] = array(
    'title' => 'Biblio settings',
    'description' => 'Configure default behavior of the biblio module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('biblio_admin_settings'),
    'file' => 'biblio.admin.inc',
  );
  $items['admin/settings/biblio/basic'] = array(
    'title' => 'Preferences',
    'type' => MENU_DEFAULT_LOCAL_TASK, 
    'weight' => -10
  );
  $items['admin/settings/biblio/import'] = array(
    'title' => 'File Import',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_import_form'),
    'file' => 'biblio.import.export.inc',
    'type' => MENU_LOCAL_TASK, 
    'weight' => -7
  );  
  $items['admin/settings/biblio/types'] = array(
    'title' => 'Type Customization',
    'page callback' => 'biblio_admin_types_form',
    'file' => 'biblio.admin.inc',
    'type' => MENU_LOCAL_TASK, 
    'weight' => -8
  );  
  $items['admin/settings/biblio/defaults'] = array(
    'title' => 'Field Defaults',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_edit_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_LOCAL_TASK , 
    'weight' => -9
  );  
  $items['admin/settings/biblio/types/add'] = array(
    'title' => '',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_add_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK 
  );  
  $items['admin/settings/biblio/types/edit'] = array(
    'title' => '',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_edit_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK 
  );  
  $items['admin/settings/biblio/types/delete'] = array(
    'title' => '',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_delete_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK 
  );  
  $items['admin/settings/biblio/types/new'] = array(
    'title' => 'Add New Type',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_add_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_LOCAL_TASK, 
    'weight' => -9
  );  
  $items['admin/settings/biblio/types/reset'] = array(
    'title' => 'Reset all types to defaults ',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_admin_types_reset_form'),
    'file' => 'biblio.admin.inc',
    'type' => MENU_LOCAL_TASK 
  );  
  $items['admin/settings/biblio/types/hide'] = array(
    'title' => '',
    'page callback' => 'biblio_admin_types_hide',
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK 
  );  
  $items['admin/settings/biblio/types/show'] = array(
    'title' => '',
    'page callback' => 'biblio_admin_types_show',
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK 
  );  
  $items['biblio/autocomplete'] = array(
    'title' => 'Autocomplete ',
    'page callback' => 'biblio_autocomplete',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  $items["$base/list"] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK, 
    'weight' => -10
  );
  $items["$base/filter"] = array(
    'title' => 'Filter',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_form_filter'),
    'access callback' => 'user_access',
    'access arguments' => array('show filter tab'),
    'type' => MENU_LOCAL_TASK, 
    'weight' => -9
  );
  $items["$base/filter/clear"] = array(
    'title' => '',
    'page callback' => 'biblio_filter_clear',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  $items["$base/help"] = array(
    'title' => 'Help',
    'page callback' => 'biblio_help_page',
    'access callback' => 'user_access',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK
  );
  $items["$base/import/form"] = array(
    'title' => '',
    'page callback' => 'drupal_get_form', 
    'page arguments' => array('biblio_import_form'),
    'file' => 'biblio.import.export.inc',
    'access callback' => 'user_access',
    'access arguments' => array('import from file'),
    'type' => MENU_CALLBACK
  );
  $items["$base/export"] = array(
    'title' => '',
    'page callback' => 'biblio_export',
    'access callback' => 'user_access',
    'access arguments' => array('show export links'),
    'file' => 'biblio.import.export.inc',
    'type' => MENU_CALLBACK
  );
  $items["$base/type/add"] = array(
    'title' => '',
    'page callback' => 'biblio_admin_type_add',
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK
  );
  $items["$base/type/remove"] = array(
    'title' => '',
    'page callback' => 'biblio_admin_type_remove',
    'file' => 'biblio.admin.inc',
    'type' => MENU_CALLBACK
  );
  $items["$base/citekey"] = array(
    'title' => '',
    'page callback' => 'biblio_citekey_view',
    'type' => MENU_CALLBACK
  );

  if (arg(1) == 'viewinline' && is_numeric(arg(2))) {
    $node = node_load(arg(2));
    if ($node->nid) {        
      $items["$base/viewinline/". arg(2)] = array(
        'title' => '',
        'page callback' => 'biblio_view_inline',
        'page arguments' => array($node),
        'access callback' => 'node_access',          
        'access arguments' => array('view', $node),
        'type' => MENU_CALLBACK
      );
    }
  }

  if (variable_get('biblio_rss', 0)) {
    $items["$base/rss.xml"] = array(
      'title' => 'RSS feed',
      'page callback' => 'biblio_feed',
      'access callback' => 'user_access',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK
    );
  }
  return $items;
} 


function biblio_filter_clear() {
  $_SESSION['biblio_filter'] = array();
  $base =  variable_get('biblio_base', 'biblio');
  drupal_goto($base);
} 

function _get_biblio_filters() {
  $fields = " b.biblio_year, b.biblio_authors, t.name , t.tid ";
  $order = " b.biblio_year DESC";
  $taxo_fields = "td.name as termname,td.tid as taxid, v.name as vocab_name";
  $taxo_order = "vocab_name ASC, termname ASC";
  $table = "{node} as n  inner join {biblio} as b on n.vid=b.vid ";
  $join = "left join {biblio_types} as t on b.biblio_type = t.tid";  
  $taxo_join = array("inner join {term_node} as tn on n.vid = tn.vid",
                     "left join  {term_data} as td on tn.tid= td.tid",
                     "left join  {vocabulary} as v on v.vid= td.vid");

  $taxo_joins = implode(' ',$taxo_join);
  
  $result = db_query("SELECT $fields FROM $table $join ORDER BY $order");
  $taxoresult = db_query("SELECT $taxo_fields FROM $table $taxo_joins ORDER BY $taxo_order");

  while ($option = db_fetch_object($result)) {
    if ($option->biblio_year == 9998) { $option->biblio_year = t("In Press"); }
    if ($option->biblio_year == 9999) { $option->biblio_year = t("Submitted"); }

    $pub_years["$option->biblio_year"] = $option->biblio_year;
    $pub_type["$option->tid"] = $option->name;
    
    $author_array = explode(";", $option->biblio_authors);
    foreach($author_array as $auth) {
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = trim($parts[0]);
      } else {
        $parts = split(" ", $auth);
        $lastname = trim(end($parts));
      } 
      if ($lastname) $pub_authors["$lastname"] = $lastname;
    } 
  } 
  while ($tax = db_fetch_object($taxoresult)) {
    $pub_taxo["$tax->taxid"] = "$tax->vocab_name - $tax->termname";
  }

  $pub_years = array_unique($pub_years);
  $pub_type = array_unique($pub_type);
  if (!empty($pub_taxo))$pub_taxo = array_unique($pub_taxo);

  if (!empty($pub_taxo)) {
    $tax_select =  array('title' => t('Term'),'options' => $pub_taxo);
  }else{$tax_select = null;
  }
  
  ksort($pub_authors);
  $filters = array(
    'author' => array('title' => t('Author'),'options' => $pub_authors),
    'type' => array('title' => t('Type'),'options' => $pub_type),
    'term_id' => $tax_select,
    'year' => array('title' => t('Year'),'options' => $pub_years)
  ); 
  
  return $filters;
}

function biblio_form_filter() {
  $session = &$_SESSION['biblio_filter'];
  $session = is_array($session) ? $session : array();
  $filters = _get_biblio_filters();

   $i = 0;
  $form['filters'] = array('#type' => 'fieldset',
    '#title' => t('Show only items where'),
    '#theme' => 'biblio_filters',
  );
  foreach ($session as $filter) {
    list($type, $value) = $filter;
    if ($type == 'category') {
      // Load term name from DB rather than search and parse options array.
      $value = module_invoke('taxonomy', 'get_term', $value);
      $value = $value->name;
    }else if ($type == 'keyword') {
      $filters[$type]['title'] = 'Keyword';
    }else {
      $value = $filters[$type]['options'][$value];
    }
    $string = ($i++ ? '<em>and</em> where <strong>%a</strong> is <strong>%b</strong>' : '<strong>%a</strong> is <strong>%b</strong>');
    $form['filters']['current'][] = array('#value' => t($string, array('%a' => $filters[$type]['title'] , '%b' => $value)));
  }

  foreach ($filters as $key => $filter) {
    if (count ($filter['options'])) {
    $names[$key] = $filter['title'];
    $form['filters']['status'][$key] = array('#type' => 'select', '#options' => $filter['options']);
   }
  }
  $form['filters']['status']['keyword']=array('#type' => 'textfield','#size' => 25, '#maxlength' => 255);
  $names['keyword'] = "Keyword";

  $form['filters']['filter'] = array('#type' => 'radios', '#options' => $names, '#default_value' => 'status');
  $form['filters']['buttons']['submit'] = array('#type' => 'submit', '#value' => (count($session) ? t('Refine') : t('Filter')));
  if (count($session)) {
    $form['filters']['buttons']['undo'] = array('#type' => 'submit', '#value' => t('Undo'));
    $form['filters']['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset'));
  }

  return  $form;
}

function biblio_form_filter_submit($form, &$form_state) {

  $op = $form_state['values']['op'];
  $filters = _get_biblio_filters();
  switch ($op) {
    case t('Filter'):
    case t('Refine'):
      if (isset($form_state['values']['filter'])) {
        $filter = $form_state['values']['filter'];

        // Flatten the options array to accommodate hierarchical/nested options.
        if (isset($filters[$filter]['options'])) {
          $flat_options = form_options_flatten($filters[$filter]['options']);
        }

        if (isset($flat_options[$form_state['values'][$filter]]) || $filter == 'keyword') {
          $_SESSION['biblio_filter'][] = array($filter, $form_state['values'][$filter]);
          $base =  variable_get('biblio_base', 'biblio');
          drupal_goto($base);

        }
      }
      break;
    case t('Undo'):
      array_pop($_SESSION['biblio_filter']);
      break;
    case t('Reset'):
      $_SESSION['biblio_filter'] = array();
      break;
  }
} 

/*function theme_biblio_node_form($form) {
echo "in node form";die;
}
*/
function biblio_submit(&$node) {
  if (!is_numeric($node->biblio_year)) {
    if ( drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("In Press")) )  {
        $node->biblio_year = 9998;
    }
    if (drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("Submitted")) ) {
       $node->biblio_year = 9999;
    }
  }
  if (variable_get('biblio_keyword_freetagging',0) && variable_get('biblio_freetagging_vocab',0)) {
    $vid = variable_get('biblio_freetagging_vocab',0);
    $node->taxonomy['tags'][$vid] = $node->biblio_keywords;
  }
}
//function biblio_pre_render($form_id, &$form, $next_page = TRUE) {
function biblio_form_alter(&$form, $form_state, $form_id) {
  global $form_values;
  if ($form_id == "biblio_node_form") {
    if (!empty($form['#node']->biblio_type)) $type = $form['#node']->biblio_type;
    if (!empty($form_state['values']['biblio_type'])) $type = $form_state['values']['biblio_type'];
    //$type = $form['#post']['biblio_type'] ? $form['#post']['biblio_type']:;
    
    if ( $type >0 ) {
    $form['biblio_type']['#default_value'] = $type;

    $form['title']['#type'] = 'textfield';

    $form['body']['#type'] = 'textarea';

    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)) {
        $fields[$row['fid']] = $row;
        if ($row['common']) $form[$row['name']]['#type'] = $row['type'];
    }
 
    $result = db_query('SELECT b.*, c.name, c.type FROM {biblio_type_details} as b INNER JOIN {biblio_fields} as c ON b.fid = c.fid where tid= %d ORDER BY b.weight ASC',$type);
    while ($row = db_fetch_array($result)) {
      $type_fields[$row['fid']] = $row;
      $form[$row['name']]['#type'] = $row['type'];
    }
    
    if (count($type_fields)) {
    // now merge the customizations with the main field array
      foreach($type_fields as $key=>$value) {
        $fields[$key] = array_merge($fields[$key],$value);
      } 
    }

    foreach ($fields as $key=>$fld) {
  
      $form[$fld['name']] = array_merge($form[$fld['name']],array(
                                          '#default_value' =>$form['#node']->$fld['name'],
                                          '#title' => $fld['title'],
                                          '#required' => $fld['required'],
                                          '#size' => $fld['size'],
                                          '#maxlength' => $fld['maxsize'],
                                          '#weight' => $fld['weight']/10,
                                          '#description' => $fld['hint'])
                                        ); // end array_merge

    } //end foreach
    $form['biblio_keywords']['#description'] = t("Separate key words with a <b>!sep</b> character", array('!sep' => variable_get('biblio_keyword_sep', ',')));

  } //endif type > 0
 } //endif ($form_id == 'biblio_node_form...  
 return $form;

}


/**
* Implementation of hook_form().
* 
* Create the form for collecting the information
* specific to this node type. This hook requires us to return some HTML
* that will be later placed inside the form.
*/
function biblio_form(&$node, &$param) {
  global $form_values;
  $output = '';
  $param['options'] = array("enctype" => "multipart/form-data"); 

  //$form['#pre_render'] = array('biblio_pre_render');

  $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE tid > -2 AND visible = 1');
  while ($option = db_fetch_object($result)) {
    $options["$option->tid"] = $option->name;
  } 
  $form['#validate'][] = 'biblio_form_validate';

  $form['biblio_type'] = array(
    '#type' => 'select', 
    '#title' => t('Publication Type'),
    '#default_value' => $node->biblio_type,
    '#options' => $options,
    '#description' => null,
    '#weight' => -5,
    '#attributes' => array('onchange'=>'document.getElementById(\'node-form\').submit()'),
    '#multiple' => false, '#required' => true);

  $form['title']= array( // this will be set to textfield type in pre_render once the pub type is set.
    '#type' => 'value',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#size' => 60,
    '#maxlength' => 255,
    '#weight' => -4
  );

    // Build the field array used to make the form
    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)) {
     // if ($row['common']) {
        $fields[$row['fid']] = $row;
     // }
    }
    
    // Now set all the fields to "value" type so the will not be visible, and 
    // then in biblio_pre_render the correct type will be set.
    foreach ($fields as $key=>$fld) {
          $form[$fld['name']] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'value',
          '#title' => $fld['title'],
          '#size' => $fld['size'],
          '#required' => $fld['required'],
          '#maxlength' => $fld['maxsize'],
          '#weight' => $fld['weight']/10,
          '#autocomplete_path' => ($fld['autocomplete']) ? 'biblio/autocomplete/'.$fld['name'] : '',
          '#description' => $fld['hint']
        );

    }    
 /*   $form['authors1'] = array('#type' => 'fieldset', 
                              '#title' => t('First Authors'),
                              '#collapsible' => TRUE, 
                              '#collapsed' => TRUE, 
                              '#weight' => 0);
    $form['authors1']['author1_lastname'] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'textfield',
          '#title' => t('lastname'),
          '#size' => 20,
          '#required' => 1,
          '#maxlength' => 75,
          '#weight' => 1,
          '#description' => ''
        );

    $form['authors2'] = array('#type' => 'value', 
                              '#title' => t('More Authors...'), 
                              '#collapsible' => TRUE, 
                              '#collapsed' => TRUE, 
                              '#weight' => 0);
  */  
    $form['body'] = array('#type' => 'value', 
                               '#title' => t('Full Text'), 
                               '#default_value' => $node->body, 
                               '#rows' => 10, '#required' => FALSE,
                               '#description' => t('You may enter a full text or HTML version of the publication here.'),
                               '#weight' => 19);
  $form['format'] = filter_form($node->format,20);

 return $form;
} 

/**
* Implementation of hook_validate().
* 
* 
* Errors should be signaled with form_set_error().
*/
function biblio_form_validate($form, &$form_state) {

  if (!$form_state['submitted']) {
    $form_state['rebuild'] = true;
    return;
 //   $form_state['storage'] = array('biblio_type' => $form_state['values']['biblio_type']);
  }  
  if ($form_state['values']['biblio_type'] == 0) {
    form_set_error('biblio_type', t('You must select the type of publication'));
    return;
  } 
  if (!$form_state['values']['biblio_authors']) {
    form_set_error('biblio_authors', t('You must supply at least one author name'));
  } 
  /*  if (!strstr("$node->biblio_authors", ";")) {
    form_set_error('biblio_authors', t('You must separate the author names with semicolons'));
  } 
*/
  if (!isset($form_state['values']['biblio_year'])) {
    form_set_error('biblio_year', t('You must supply the year of publication'));
  }
  if ( !is_numeric($form_state['values']['biblio_year']) && $form_state['values']['biblio_year'] != t("In Press") && $form_state['values']['biblio_year'] != t("Submitted") )
  {  
    form_set_error('biblio_year', t('Year of Publication must be a number between 1 and @thisyear or the words "In Press" or "Submitted" ', array('@thisyear' => $today['year']+1)));
  
  } 
  $today = getdate();
  if ( is_numeric($form_state['values']['biblio_year']) && ($form_state['values']['biblio_year'] < 1 || $form_state['values']['biblio_year'] > $today['year']+1)) {
    form_set_error('biblio_year', t('Year of Publication must be a number between 1 and @thisyear', array('@thisyear' => $today['year'])));
  }
  /*  if (!$node->biblio_secondary_title) {
    form_set_error('biblio_secondary_title', t('You must supply the Journal Title, Conference Name or Book Title'));
  } 
*/

} 
function biblio_insert_authors($nid, $authors=array() ) {

}
/**
* Implementation of hook_insert().
* 
* As a new node is being inserted into the database, we need to do our own
* database inserts.
*/
function biblio_insert($node) {
  // Prepare the query:
  $fields = biblio_get_db_fields();
  $node->biblio_coins = biblio_coins($node);

  foreach ($node as $key => $value) {
    if (in_array((string) $key, $fields)) {
      $k[] = db_escape_string($key);
      $v[] = $value;
      $s[] = "'%s'";
    } 
  } 
  // Insert the node into the database:
  db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
} 

/**
* Implementation of hook_update().
* 
* As an existing node is being updated in the database, we need to do our own
* database updates.
*/
function biblio_update($node) {
  $fields = biblio_get_db_fields();
  $node->biblio_coins = biblio_coins($node);
  if (!is_numeric($node->biblio_year)) {
    if ( drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("In Press")) )  {
        $node->biblio_year = 9998;
    }
    if (drupal_strtoupper($node->biblio_year) == drupal_strtoupper(t("Submitted")) ) {
       $node->biblio_year = 9999;
    }
  }

  foreach ($node as $key => $value) {
    if (in_array($key, $fields) && $key !="0") { //$key != "0" to fix a bug related to book module
      $k[] = db_escape_string($key);
      $q[] = end($k) . " = '%s'";
      $v[] = $value;
      $s[] = "'%s'";
    } 
  } 
  // Update the node in the database:
  if ($node->revision) {
    db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
  }else{
    db_query("UPDATE {biblio} SET " . implode(', ', $q) . " WHERE vid = '$node->vid'", $v);
  }  
} 

/**
* Implementation of hook_delete().
* 
* When a node is deleted, we need to clean up related tables.
*/
function biblio_delete($node) {
  db_query('DELETE FROM {biblio} WHERE nid = %d', $node->nid);
} 

/**
* Implementation of hook_load().
* 
* This hook is called
* every time a node is loaded, and allows us to do some loading of our own.
* 
*/
function biblio_load($node) {
  $additions = db_fetch_object(db_query('SELECT * FROM {biblio} WHERE vid = %d', $node->vid));
  if ( $additions->biblio_year == 9998)  {
        $additions->biblio_year = t("In Press");
  }
  if ($additions->biblio_year == 9999) {
       $additions->biblio_year = t("Submitted");
  }
  return $additions;
}
 
function biblio_citekey_view() {
  $citekey = arg(2);
  $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
  if ($nid->nid > 0) {
    $node = node_load($nid->nid);
    return node_page_view($node);
  } else {
    return t("Sorry, citekey @cite not found", array('@cite'=>$citekey));
  }

}

function biblio_citekey_generate() {
  
  $result = db_query("SELECT n.title, b.biblio_citekey, b.biblio_authors, b.biblio_year FROM {node} AS n LEFT JOIN {biblio} AS b ON n.nid = b.nid WHERE n.type = 'biblio' ");
  while ($node = db_fetch_object($result)) {
     if (!$node->biblio_citekey) {
       $author_array = explode(";", _biblio_parse_authors($node->biblio_authors));
       $auth = $author_array[0];
       if (strstr($auth, ",")) {
         $parts = split(",", $auth);
         $lastname = $parts[0];
       } else {
         $parts = split(" ", $auth);
         $lastname = end($parts);
       } 

     }    
  }  
}

function biblio_view_inline(&$node) {
  $style = variable_get('biblio_style', 'classic');
  $base =  variable_get('biblio_base', 'biblio'); 
  
  $output  = '<div class="biblio-inline">';
  $output .= theme('biblio_long', $node, $base, $style);
  $output .= '</div>';
  print $output;
}
/**
* Implementation of hook_view().
* 
* This is a typical implementation that simply runs the node text through
* the output filters.
*/
function biblio_view(&$node, $teaser = false, $page = false) {
  theme('biblio_add_css');
  if ( strlen(trim($node->body)) ) $node = node_prepare($node, $teaser);
  
  $style = variable_get('biblio_style', 'classic');
  $base =  variable_get('biblio_base', 'biblio'); 
  switch (variable_get('biblio_node_layout', '0')) {
  case 'orig':
  case 'ft':
    $node->content['body']['#value'] = theme('biblio_long', $node,$base,$style);
    break;
  case 'tabular':
  default:
    $node->content['body']['#value'] = theme('biblio_tabular',$node, $base, $teaser);
    break;
  }

  if ($page) {
    drupal_set_breadcrumb(array(l(t('Home'), NULL), l(drupal_ucfirst($base), $base)));
  }  

  return $node;

} 

/**
* Implementation of hook_block().
* 
* Generates a block containing the latest poll.
*/
function biblio_block($op = 'list', $delta = 0) {
  if (user_access('access content')) {
    if ($op == 'list') {
      $blocks[0]['info'] = t('Most recent publications');
      return $blocks;
    } else if ($op == 'view') {
      // Retrieve the latest pubs
      $num_in_block = variable_get('biblio_rowsperblock', 4);
      $block_order  = variable_get('biblio_block_order', 'n.created');
      $num_rows = db_result(db_query_range(db_rewrite_sql("SELECT COUNT(*) FROM {node} n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY $block_order DESC"), 0, $num_in_block));
      if ($num_rows) {
        $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.status, b.biblio_year FROM {node} n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY $block_order DESC"), 0, $num_in_block);
        $base =  variable_get('biblio_base', 'biblio');
        $block['subject'] = t(variable_get('biblio_block_title', 'New Publications'));
        $block['content'] .= '<div class="item-list"><ul>';
        while ($pub = db_fetch_object($result)) {
          $block['content'] .= '<li >' . l("$pub->title", "node/$pub->nid") . '</li>';
        }
        $block['content'] .= '</ul>';
        if (variable_get('biblio_rss', 0)) { 
          $block['content'] .=  theme('feed_icon', url("$base/rss.xml"));
        }
        $block['content'] .= '</div>';
      } 
      return $block;
    } 
  } 
} 

function biblio_feed() {
      
  $result = db_query_range(db_rewrite_sql("SELECT * FROM {node} AS n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY n.created DESC"), 0, variable_get('biblio_rss_number_of_entries',10));
  $channel['title'] = variable_get('site_name', 'Drupal') .' - '. t("New Publications");
  node_feed($result, $channel);

}




function biblio_show_results($result, $count = 0, $attrib = array("sort" => 'year', 'order' => 'DESC'), $args = null,$inline=false) {
  global $pager_total_items;
  $base =  variable_get('biblio_base', 'biblio');
  $style = variable_get('biblio_style', 'classic');

  theme('biblio_add_css');
  if (variable_get('biblio_rss', 0)) {  
    drupal_set_html_head('<link rel="alternate" type="application/rss+xml" title="'.variable_get('site_name', 'Drupal').' RSS" href="'.url("$base/rss.xml").'" />');
  }  
  $pub_types = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid>0');
  while ($option = db_fetch_object($pub_types)) {
    $pub_type["$option->tid"] = $option->name;
  } 
  if (!$inline) {
    // Add some links to the top of the page to change the sorting/ordering...
    $order = ($attrib['order'] == "desc" || $attrib['order'] == "DESC")?"asc":"desc";
    if ( biblio_access('export',$node)) {
      $content .= '<div class="biblio_export">'.t('Export @count results', array('@count' => $pager_total_items[0])).':['.l("Tagged","$base/export/tagged"). ']['.l("XML","$base/export/xml"). ']['.l("BibTex","$base/export/bib").']</div>';
    }else{
      $content .= '<div class="biblio_export">'.t('Found @count results', array('@count' => $pager_total_items[0])) .'</div><br />';    
    }
    if (user_access('show sort links')) {
      $options = array('attributes'=>array("title"=>t("Click a second time to reverse the sort order")));

      $sort_links =  variable_get('biblio_sort_tabs', array('author'=>'author','title'=>'title','type'=>'type','year'=>'year'));

      $content .= '<div class="biblio_sort">';
      foreach($sort_links as $key => $link) { 
        if ($key === $link) {
          $content .= t('Sort by').':';
          break;
        }
      }
      
      if ($sort_links['year']) {
        $options['query'] = "sort=year&order=$order";
        $content .= "[".l(t("Year"),$_GET['q'],$options)."]";
      }
      if ($sort_links['title']) { 
        $options['query'] = "sort=title&order=$order";
        $content .= "[".l(t("Title"),$_GET['q'],$options)."]";
      }
      if ($sort_links['type']) {
        $options['query'] = "sort=type&order=$order";
        $content .= "[".l(t("Type"),$_GET['q'],$options)."]";
      }
      if ($sort_links['author']) {
        $options['query'] = "sort=author&order=$order";
        $content .= "[".l(t("Author"),$_GET['q'],$options)."]";
      }
      if ($sort_links['keyword']) {
        $options['query'] = "sort=keyword&order=$order";
        $content .= "[".l(t("Keyword"),$_GET['q'],$options)."]";
      }
      $content .= "</div> ";
    }
    
    $session = &$_SESSION['biblio_filter'];
    // if there are any filters in place, print them at the top of the list
    if (count($args)) {
      $content .= '<b>'.t('Filters').': </b>';
      while ($args) {
        $type = $args[0];
        array_shift($args);
        $value = db_escape_string($args[0]);
        if ($type == 'term_id') {
          $term_result = db_query('SELECT name FROM {term_data} as td WHERE td.tid = %d',$value);
          $term = db_fetch_object($term_result);
          $value = $term->name;
          $type = t("Taxonomy Term");
        }
        if ($type == 'type') $value = $pub_type["$value"];
        array_shift($args);
        $params = array('%a' =>  $type , '%b' =>  $value );
        $content .= ($i++ ? t('<em> and</em> <strong>%a</strong> is <strong>%b</strong>', $params) : t('<strong>%a</strong> is <strong>%b</strong>', $params)) ;
      } 
      $content .= '&nbsp;&nbsp;'.l('['.t('Clear All Filters').']',"$base/filter/clear");
    }
  }
  if ($inline === true) print '<div class="biblio-inline">';
  while ($node = db_fetch_object($result)) {
    if (isset($node->biblio_year) && ($node->biblio_year == 9998))  $node->biblio_year = t("In Press") ;
    if (isset($node->biblio_year) && ($node->biblio_year == 9999))  $node->biblio_year = t("Submitted") ;
    switch ($attrib['sort']) {
      case 'title':
        if ( drupal_substr(drupal_ucfirst(ltrim($node->title)), 0, 1)  != $_char) {
          $_char =  drupal_substr(drupal_ucfirst(ltrim($node->title)), 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        } 
        break;
      case 'author':
        if ( drupal_substr(drupal_ucfirst(ltrim($node->biblio_authors)), 0, 1) != $_char) {
          $_char = drupal_substr(drupal_ucfirst(ltrim($node->biblio_authors)), 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        } 
        break;
      case 'type':
        if ($node->biblio_type != $_type) {
          $_type = $node->biblio_type;
          $name = db_result(db_query("SELECT name FROM {biblio_types} as t where t.tid=%d", $node->biblio_type)) ;
          $content .= '<div class="biblio-year">' . $name . "</div>\n";
        } 
        break;
      case 'keyword': 	// added msh 08 aug 07
        $tok = drupal_ucfirst(strtok($node->biblio_keywords, variable_get('biblio_keyword_sep', ',')));
        if (empty($tok)) {
          $tok = t("No Keywords");
        }
        if ($tok != $name) {
          $name = $tok;
          if ($name != '') { 
            $content .= '<div class="biblio-year">' . $name . "</div>\n";
          }
        }        
        break;
      case 'year':
      default:
        if ($node->biblio_year != $_year) {
          $_year = $node->biblio_year;          
          $content .= '<div class="biblio-year">' .$_year. "</div>\n";        
       } 
    } //end switch
    $content .= '<div class="biblio-entry">' . "\n";
    $inline_links = ($inline && variable_get('inlinemode_in_links',0)) ? true : false;
    $content .= theme('biblio_list', $node,$base,$style,$inline_links);
    $content .= "</div>\n";
  } //end while
  $content .= theme('pager', 0, variable_get('biblio_rowsperpage', 25));
  if ($count == 0) {
    $content .= "<h3>".t("No items found")."</h3>";
    if (strstr($content, "Filters:")) {
      $content .= t('!modify_link or !remove_link your filters and try again.', array('!modify_link' => l(t('Modify'),"$base/filter"), '!remove_link' => l(t('remove'),"$base/filter/clear")));
    }
  } 
  if (!$inline) {
    print theme('page', $content);
  }elseif ($inline == 'profile'){
    return $content ;
  }else{ 
    print $content . "</div>";
  }

} 

function biblio_db_search() {
global $user;
$inline = false;
$join = array();
  $join[] = "left join {biblio} b  on n.vid=b.vid";
   if (variable_get('biblio_view_only_own', 0) ) {
      $limit .= " AND n.uid=$user->uid ";
   }

  $pager_attrib = array("sort" => variable_get('biblio_sort', 'year'), 'order' => variable_get('biblio_order', 'DESC'));
  $limits = null;

  if (isset($_GET['order'])) {
    $pager_attrib['order'] = ($_GET['order'] == 'desc') ? 'desc' : 'asc';
  }
  if (isset($_GET['sort'])) {
    $pager_attrib['sort'] = check_plain($_GET['sort']);
  } 

  switch ($pager_attrib['sort']) {
    case 'type':
      $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
      break;
    case 'title':
      $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
      break;
    case 'author':
      /*$join[] = "inner join {biblio_has_author} as ha on a.aid = ha.aid"; 
      $join[] = "inner join  {biblio_author_index} as a on b.nid= ha.nid";
      $sortby = " ORDER BY a.author %s ";
      $where[] = "ha.rank = 1 ";
      */
      $sortby = "ORDER BY SUBSTRING(LTRIM(b.biblio_authors),1,1) %s, b.biblio_year DESC ";
      break;
    case 'keyword': // added msh 070808
      $sortby = "ORDER BY SUBSTRING(LTRIM(b.biblio_keywords),1,4) %s, b.biblio_keywords ASC ";
    break;
    case 'year':
    default:
      $sortby = "ORDER BY b.biblio_year %s, b.biblio_date DESC, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
  } //end switch
  if (!isset($_SESSION['biblio_filter']) || !is_array($_SESSION['biblio_filter'])) {
    $_SESSION['biblio_filter'] = array();
  } 

  $session = &$_SESSION['biblio_filter'];
  
  $numargs = func_num_args();
  $arg_list = func_get_args();

  foreach ($session as $filter) {
    $arg_list = array_merge($arg_list, $filter);
  } 
  if (count($arg_list) >= 2) {
    $args = array();
    while ($arg_list) {
      $type = $arg_list[0];
      array_shift($arg_list);
      $operator = ($operator)?$operator:" AND "; //defaults to AND
      switch ($type) {
        case 'and':
          $operator = " AND ";
          break;
        case 'or':
          $operator = " OR ";
          break;
        case 'inline':
          $inline = true;
          break;
        case 'profile':
          $inline = "profile";
          break;
        case 'term':
        case 'term_id':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $join[] = "inner join {term_node} as tn on n.vid = tn.vid";
          if ($type == 'term') {
            $join[] = "inner join  {term_data} as td on tn.tid= td.tid";
            $where[] = "td.name = '%s' ";
          }elseif ($type == 'term_id') {
            $where[] = "tn.tid = '%d' ";          
          }  
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          break;
        case 'author':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = 'b.biblio_authors RLIKE "[[:<:]]%s[[:>:]]" ';
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $operator = NULL;
          break;
        case 'publisher':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_publisher RLIKE '%s' ";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $operator = NULL;
          break;
        case 'year':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_year=%d ";
          //$limit .= " AND b.biblio_year=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'uid':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $where[] = "n.uid=%d ";
          //$limit .= " AND b.biblio_year=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'keyword':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_keywords RLIKE '%s' ";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          $operator = NULL;
          break;
        case 'type':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $limit .= $operator. "b.biblio_type=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          $operator = NULL;
          break;
        case 'order':
          $term = (db_escape_string($arg_list[0]) == 'desc')?'desc':'asc';
          array_shift($arg_list);
          $pager_attrib['order'] = $term;
          array_push($args, $type, $term);
          break;
        case 'sort':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $pager_attrib['sort'] = $term;
          array_push($args, $type, $term);
          switch ($term) {
            case 'type':
              $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
              break;
            case 'title':
              $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
              break;
            case 'year':
            default:
              $sortby = "ORDER BY b.biblio_year %s, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
          } //end switch
          break;
        default:
          $fields = biblio_get_db_fields();
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          if (in_array("biblio_$type",$fields))
          {
            $where[] = "b.biblio_$type RLIKE '%s' ";
            $terms[] = db_escape_string($term[0]);
            array_push($args, $type, $term[0]);
            $operator = NULL;
          }
          break;
            
      } 
    } 
  } 
  $where[] = "n.type='biblio' ";
  if ($user->uid != 1 ) {
    $where[] = 'n.status = 1 ';
  }//show only published entries to everyone except admin
  
  $joins = implode(' ', $join);

  $where_clause = count($where) > 1 ? '('. implode(') AND (', $where) .')': $where[0];

  $query = db_rewrite_sql("SELECT DISTINCT n.*, b.* FROM {node} n $joins  WHERE $where_clause $published $limit $sortby ");
  $count_query = db_rewrite_sql("SELECT DISTINCT COUNT(*) FROM {node} n $joins  WHERE $where_clause $published $limit ");
  $_SESSION['last_biblio_query'] = $query;
  $terms[] = $pager_attrib['order'];
  $_SESSION['last_biblio_query_terms'] = $terms;
  $count = db_result(db_query($count_query,$terms));

  $result = pager_query($query, variable_get('biblio_rowsperpage', 25),0,$count_query,$terms);

  return biblio_show_results($result, $count, $pager_attrib, $args,$inline);
} 

 
function biblio_get_db_fields() {
  $fields = array();
  $fields[] = 'nid';  
  $fields[] = 'vid';
  $fields[] = 'biblio_type';
  $result = db_query('SELECT name FROM {biblio_fields} ');
  while ($field = db_fetch_array($result)) {
    $fields[] = $field['name'];
  }
  return $fields ;
} 
function _biblio_author_links($author, $base='biblio', $inline = FALSE) {
  $options = array();
  $inline = $inline ? "/inline" : "";
  //$attrib = (variable_get('biblio_links_target_new_window',null)) ? array('target'=>'_blank') : null;
  
  if (isset($_GET['sort'])) {
    $options['query']  .= "sort=" . $_GET['sort'];
  } 
  if (isset($_GET['order'])) {
     $options['query']   .= $options['query'] ? "&" : "" ;
     $options['query']   .= "order=" . $_GET['order'];
  } 
  
  $html = "";
  $author_array = explode(";", $author);
  
  foreach($author_array as $auth) {
    $html .= (empty($html))? "" : "; ";
    if (strstr($auth, ",")) {
      $parts = split(",", $auth);
      $lastname = $parts[0];
    } else {
      $parts = split(" ", $auth);
      $lastname = end($parts);
    } 
    // list($lastname, $init) = split(",", $auth);

    $html .= l(trim($auth), "$base/author/" . trim($lastname) . $inline,$options );
  } 
  return $html;
} 
function biblio_author_index_shutdown() {
  global  $biblio_last_nid;

  if ($biblio_last_nid) {
    variable_set('biblio_ai_last_nid', $biblio_last_nid);
  }

}
function biblio_update_author_index() {
  global  $biblio_last_nid;

  //register_shutdown_function('biblio_author_index_shutdown');
  $biblio_last_nid = variable_get('biblio_ai_last_nid', 0);
  $biblio_max_count = variable_get('biblio_ai_max_count', 100);
  $count = 0;
  $result  = db_query("SELECT nid, biblio_authors FROM {biblio} WHERE nid > %d",$biblio_last_nid);
  while ( ($row = db_fetch_object($result)) && ($count < $biblio_max_count) ) {
    $author_array = explode(";", $row->biblio_authors);
    $rank = 0;
    foreach($author_array as $auth) {
      $rank++;
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = $parts[0];
      } else {
        $parts = split(" ", $auth);
        $lastname = end($parts);
      } 
      _biblio_author_index_insert($row->nid, $lastname,$rank);
      $biblio_last_nid = $row->nid;  
    }
    $count++;
  } 
    variable_set('biblio_ai_last_nid', $biblio_last_nid);

  return ;
} 

function _biblio_author_index_insert($nid, $author,$rank) {
  $uc_author = trim(drupal_strtoupper($author));
  $result = db_query("SELECT * FROM {biblio_author_index} WHERE author = '%s'",$uc_author);
  $author_exist = db_result(db_query("SELECT * FROM {biblio_author_index} WHERE author = '%s'",$uc_author));

  if ($author_exist) {
    $row = db_fetch_object($result);
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d,%d,%d)",$nid,$row->aid,$rank);   
  }else{
    $aid = db_last_insert_id('{biblio_author_index}_aid');
    $result = db_query("INSERT INTO {biblio_author_index} (`aid`,`author`) VALUES (%d,'%s')",$aid,$uc_author);   
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d, %d, %d)",$nid,$aid,$rank);   
  
  }
  return ;
}
function _biblio_keyword_links($keywords,$base='biblio') {
  $options = array();
  if (isset($_GET['sort'])) {
    $options['query']  .= "sort=" . $_GET['sort'];
  } 
  if (isset($_GET['order'])) {
    $options['query']  .= $options['query'] ? "&" : "";
    $options['query']  .= "order=" . $_GET['order'];
  } 
  
  $html = "";
  $sep = variable_get('biblio_keyword_sep', ',');
//  if (strstr($keywords,';')) {
    $keyword_array = explode($sep, $keywords);
/*  }elseif (strstr($keywords,',')) {
    $keyword_array = explode(",", $keywords);  
  }else{
    $keyword_array = explode(" ", $keywords);  
  }
*/
  foreach($keyword_array as $kw) {
    $html .= (empty($html))? "" : "; ";
    $html .= l(trim($kw), "$base/keyword/" . trim($kw) . $sort, $options);
  } 
  return $html;
}

function _biblio_parse_authors($authors) {
$and = array(" and ", " And ", " AND ");
$authors = str_replace($and, ", ", $authors); // change the word "and" to a comma
$authors = str_replace(" ,", ",", $authors); // fix some potential typos
$authors = str_replace(",,", ",", $authors); // ditto 
// $authors = str_replace(";",",",$authors);
$chunks = explode(";", $authors); // split the authors on the semicolon
$num_chunks = count($chunks);

  for($i = 0;  $i < count($chunks);  $i++) {
    $suffix = _biblio_get_suffix($chunks[$i]); // get and strip out the suffix
    $prefix = _biblio_get_prefix($chunks[$i]); // get and strip out the prefix
    if (strstr($chunks[$i], ",")) { // we probably have lastname first
      $subchunks = explode(",", trim($chunks[$i]));
      $lastname = $subchunks[0];
      $subchunks = explode(" ", trim($subchunks[1]));
      $initials = "";
      for ($j = 0; $j < count($subchunks) ;  $j++) {
        if (substr_count($subchunks[$j], '.')) {
          $initials .= $subchunks[$j];
        } else {
          $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
        } 
      } 
    } else { // we have some form of firstname first (Fistname I. Lastname)
      $subchunks = explode(" ", trim($chunks[$i]));
      $lastname = end($subchunks);
      $initials = "";
      for ($j = 0;
        $j < count($subchunks) - 1 ;
        $j++) {
        if (substr_count($subchunks[$j], '.')) {
          $initials .= $subchunks[$j];
        } else {
          $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
        } 
      } 
    } 
    $chunks[$i] = trim($prefix . $lastname . ', ' . $initials . ' ' . $suffix);
  }
   
  return implode("; ", $chunks);
} 

function _biblio_get_suffix(&$name) {
$suffix = null;
  if (preg_match("/[, \.]+(Jr|Sr|Snr)\.?\s*$/", $name, $match)) {
    $suffix = $match[0];
    $Text = str_replace($Suffix, "", $name);
  } elseif (preg_match("/([, \.]+)(Jr|Sr|Snr)[. ]/", $name, $match)) {
    $suffix = $match[1];
    $name = str_replace($Suffix, "", $name);
  } 

return $suffix;
} 
function _biblio_get_prefix(&$name) {
  $prefix = null;
  $name = " " . $name;
  $prefs = array(" Van ", " van ", " von ", " den ", " der ", " de ", " De ", " ter ", " Ter ", "Vander ");
  if (strstr($name, " Van ")) $prefix .= "Van ";
  if (strstr($name, " van ")) $prefix .= "van ";
  if (strstr($name, " Vander ")) $prefix .= "Vander ";
  if (strstr($name, " von ")) $prefix .= "von ";
  if (strstr($name, " de ")) $prefix .= "de ";
  if (strstr($name, " De ")) $prefix .= "De ";
  if (strstr($name, " den ")) $prefix .= "den ";
  if (strstr($name, " der ")) $prefix .= "der ";
  if (strstr($name, " ter ")) $prefix .= "ter ";
  if (strstr($name, " Ter ")) $prefix .= "Ter ";
  if (strlen($prefix)) $name = str_replace($prefs, "", $name);
  $name = trim($name);
  return $prefix;
} 

function author_test() {
    $result  = db_query("SELECT nid, biblio_authors FROM {biblio} ");
    $carray = array();
    while ($row = db_fetch_object($result)) {
    //    $carray = explode(";",$authors->biblio_authors);
      //  $creators = _parse_author_array($carray);
      _biblio_author_index($row->nid,$row->biblio_authors);
      // echo $authors->nid;
         
    }
    $creators = _parse_author_array($carray);
}
function _parse_author_array($authorArray)
{
//	$input = trim($input);
// split on ' and ' 
//	$authorArray = preg_split("/\s(and)\s/i", $input);
// check if there's anything that looks like et. al
  $count=1;
	foreach($authorArray as $value)
	{
		$appellation = $prefix = $surname = $firstname = $initials = '';
		$author = explode(",", preg_replace("/\s{2,}/", ' ', trim($value)));
		$size = sizeof($author);
// No commas therefore something like Mark Grimshaw, Mark Nicholas Grimshaw, M N Grimshaw, Mark N. Grimshaw
		if ($size == 1)
		{
			$author = split(" ", $value);
// last of array is surname (no prefix if entered correctly)
			$surname = array_pop($author);
		}
// Something like Grimshaw, Mark or Grimshaw, Mark Nicholas  or Grimshaw, M N or Grimshaw, Mark N.
		else if ($size == 2)
		{
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
// If $size is > 2, we're looking at something like Bush, George W, III
		else
		{
// last of array is 'Jr.', 'IV' etc.
			$appellation = array_pop($author);
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
		$remainder = join(" ", $author);
		list($firstname, $initials) = _grabFirstnameInitials($remainder);
		$surname = $surname . ' ' . $appellation;
		$creators[] = array('first_name'=> trim("$firstname"), 
                        'initials'  => trim("$initials"), 
                        'last_name' => trim("$surname"), 
                        'prefix'    => trim("$prefix"),
                        'order'     => "$count");
    $count++;
	}
	if (isset($creators))
		return $creators;
	return FALSE;
}
// grab firstname and initials which may be of form "A.B.C." or "A. B. C. " or " A B C " etc.
function _grabFirstnameInitials($remainder)
{
	$firstname = $initials = '';
	$array = split(" ", $remainder);
	foreach($array as $value)
	{
		if (preg_match("/[a-zA-Z]{2,}/", trim($value)))
			$firstnameArray[] = trim($value);
		else
			$initialsArray[] = str_replace(".", " ", trim($value));
	}
	if (isset($initialsArray))
	{
		foreach($initialsArray as $initial)
			$initials .= ' ' . trim($initial);
	}
	if (isset($firstnameArray))
		$firstname = join(" ", $firstnameArray);
	return array($firstname, $initials);
}
// surname may have title such as 'den', 'von', 'de la' etc. - characterised by first character lowercased
function _grabSurname($input)
{
	$surnameArray = split(" ", $input);
	foreach($surnameArray as $value)
	{
		$firstChar = substr($value, 0, 1);
		if ((ord($firstChar) >= 97) && (ord($firstChar) <= 122))
			$prefix[] = $value;
		else
			$surname[] = $value;
	}
	if (isset($surname)) $surname = join(" ", $surname);
	if (isset($prefix))
	{
		$prefix = join(" ", $prefix);
		return array($surname, $prefix);
	}
	return array($surname, FALSE);
}

function biblio_views_tables() {
  
  $table = views_new_table('biblio', 'internal', 'node', 'vid', 'vid');
  $result = db_query('SELECT name,title FROM {biblio_fields} ');
  while ($field = db_fetch_array($result)) {
    views_table_add_field($table, $field['name'], "Biblio: ".$field['title'], "", array(
      'sortable' => true,
      'notafield' => false,
    ));
  }

  $tables['biblio'] = $table;
  $table = views_new_table('biblio_types', 'internal', 'biblio', 'tid', 'tid');
  $tables['biblio_types'] = $table;
  return $tables;
}
function biblio_views_default_views() {
  $view = new stdClass();
  $view->name = 'biblioview';
  $view->description = 'Shows a summary view of biblio entries';
  $view->access = array ();
  $view->view_args_php = '';
  $view->page = TRUE;
  $view->page_title = 'Biblio';
  $view->page_header = '';
  $view->page_header_format = '1';
  $view->page_footer = '';
  $view->page_footer_format = '1';
  $view->page_empty = '';
  $view->page_empty_format = '1';
  $view->page_type = 'table';
  $view->url = 'biblioview';
  $view->use_pager = TRUE;
  $view->nodes_per_page = '10';
  $view->sort = array ();
  $view->argument = array (
    array (
      'type' => 'nodetype',
      'argdefault' => '2',
      'title' => '',
      'options' => '',
      'wildcard' => 'biblio',
      'wildcard_substitution' => '',
    ),
  );
  $view->field = array (
    array (
      'tablename' => 'biblio',
      'field' => 'biblio_year',
      'label' => 'Year',
      'sortable' => '1',
      'defaultsort' => 'DESC',
    ),
    array (
      'tablename' => 'biblio',
      'field' => 'biblio_authors',
      'sortable' => '1',
      'label' => 'Author',
    ),
    array (
      'tablename' => 'node',
      'field' => 'title',
      'label' => 'Title',
      'handler' => 'views_handler_field_nodelink',
       'sortable' => '1',
     'options' => 'link',
    ),
  );
  $view->filter = array ();
  $view->exposed_filter = array ();
  $view->requires = array(biblio, node);
  $views[$view->name] = $view;
  return $views;
}

function biblio_nodeapi($node, $op) {
  switch ($op) {
  case 'delete revision':
      db_query('DELETE FROM {biblio} WHERE vid = %d', $node->vid);
      break;
      
  }

}

 /*******************************************
  * Filter
  * Largely inspired from the footnote module 
  *  
 *******************************************/
 
function _biblio_citekey_print($citekey) {
   $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
   if ($nid->nid > 0) {
     $style = variable_get('biblio_style', 'classic');
     $base =  variable_get('biblio_base', 'biblio'); 
     $node = node_load($nid->nid);     
     return theme('biblio_short', $node, $base, $style);
   } else {
     return t("Citekey @cite not found", array('@cite' => $citekey));
   }
 
}
 
 
 /**
  * Implementation of hook_filter_tips().
  *
  * This hook allows filters to provide help text to users during the content
  * editing process. Short tips are provided on the content editing screen, while
  * long tips are provided on a separate linked page. Short tips are optional,
  * but long tips are highly recommended.
  */
function biblio_filter_tips($delta, $format, $long = FALSE) {
   switch ($delta) {
     case 0:
       if ($long) {
         return t('You can cite references directly into texts with <code>&lt;bib&gt;citekey&lt;/bib&gt;</code>. This will be replaced with a running number (the publication reference) and the publication referenced by the citekey within the &lt;bib&gt; tags will be print to the bottom of the page (the reference).');
       }
       else {
         return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');
       }
       break;
   }
}
 
 /**
  * Implementation of hook_filter().
  *
  * The bulk of filtering work is done here. This hook is quite complicated, so
  * we'll discuss each operation it defines.
  */
function biblio_filter($op, $delta = 0, $format = -1, $text = '') {
   // The "list" operation provides the module an opportunity to declare both how
   // many filters it defines and a human-readable name for each filter. Note that
   // the returned name should be passed through t() for translation.
   if ($op == 'list') {
     return array(
       0 => t('References &lt;bib&gt;'),
     );
   }
   if ($op == 'no cache') { return true; }
  
   // All operations besides "list" provide a $delta argument so we know which
   // filter they refer to. We'll switch on that argument now so that we can
   // discuss each filter in turn.
   switch ($delta) {
 
     // First is the html footnotes filter
     case 0:
 
       switch ($op) {
         // This description is shown in the administrative interface, unlike the
         // filter tips which are shown in the content editing interface.
         case 'description':
           return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');
 
         // We don't need the "prepare" operation for this filter, but it's required
         // to at least return the input text as-is.
         //TODO: May need to escape <fn> if we use HTML filter too, but Footnotes could be first
         case 'prepare':
           return $text;
 
         // The actual filtering is performed here. The supplied text should be
         // returned, once any necessary substitutions have taken place.
         case 'process':
          if (variable_get('biblio_footnotes_integration', 0) && module_exists('footnotes'))
          {  // this is used with footnote module integration to replace the <bib> tags with <fn> tags
             $text = preg_replace_callback('|<bib>(.*?)</bib>|s', '_biblio_filter_footnote_callback', $text);
             return $text;
          }else{
             $text = preg_replace_callback('|<bib>(.*?)</bib>|s', '_biblio_filter_replace_callback', $text);
             
             //Replace tag <footnotes> with the list of footnotes.
             //If tag is not present, by default add the footnotes at the end.
             //Thanks to acp on drupal.org for this idea. see http://drupal.org/node/87226 
             $footer = '';
             $footer = _biblio_filter_replace_callback(NULL, 'output footer');
             if ( preg_match( '/<bibliography(\/( )?)?>/', $text ) > 0 ) {
               $text = preg_replace('/<bibliography(\/( )?)?>/', $footer, $text, 1);
               return $text;
             }
             else {
               return $text . "\n\n" . $footer;
             }
          }
       }
       break;
   }
}
 
function _biblio_filter_footnote_callback( $matches ) {
   
  $text = '<fn>' . _biblio_citekey_print($matches[1]) . "</fn>";
 
  return $text;
 
}
 
 /**
  * Helper function called from preg_replace_callback() above
  *
  * Uses static vars to temporarily store footnotes found.
  * In my understanding, this is not threadsafe?!
  */
function _biblio_filter_replace_callback( $matches, $op = '' ) {
   static $n = 0;
   static $store_matches = array();
   $str = '';
   
   if ( $op == 'output footer' ) {
     theme('biblio_add_css');     
     if ( $n > 0 ) {
       $str = '<p><hr /><p><h3>'.t('References').'</h3></p>';
       $str .= '<div class="references"><ol>';
       for( $m = 1; $m <= $n; $m++ ) {
         $str .= '<li id="reference' . $m . '">' . _biblio_citekey_print($store_matches[ $m - 1 ]) . " </li>\n\n";
       }
       $str .= '</ol></div>';
     }
     $n = 0;
     $store_matches = array();
     return $str;
   }
 
   //default op: act as called by preg_replace_callback()
   array_push( $store_matches, $matches[1] );
   $n++;
   $allowed_tags = array();
   $title = filter_xss($matches[1], $allowed_tags);
   //html attribute cannot contain quotes
   $title = str_replace('"', "&quot;", $title);
   //remove newlines. Browsers don't support them anyway and they'll confuse line break converter in filter.module
   $title = str_replace("\n", " ", $title);
   $title = str_replace("\r", "", $title);
   //return '<sup class="see_reference" title="'. $title .'"><a href="#reference' . $n . '">' . $n . '</a></sup>';  
   //$text = '<span><a href="#reference' . $n . '">[' . $n . ']</a> </span>';
   //$text = '<span>[' . $n . ']</span>';
   //$text .= '<span class="hovertip">'._biblio_citekey_print($title) .'</span>';
 
   $text = '<span hovertip="reference'. $n .'">[' . $n .']</span>';
   if (module_exists('hovertip')) { 
     $text .= '<div id="reference'. $n .'" class="hovertip"><h1>Reference</h1>'._biblio_citekey_print($title) .'</div>';
   }
   return $text;
 
}
function biblio_taxonomy($op, $type, $array = NULL) { 

  if ($op == 'delete' && $term['vid'] == variable_get('biblio_freetagging_vocab',0)) {
    switch ($type) {
      case 'term':
        break;
      case 'vocabulary':
        variable_del('biblio_keyword_freetagging');
        variable_del('biblio_freetagging_vocab');
        break;
    
    }
    
  }  

}


function biblio_openURL($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome

//  global $openURLResolver; // these variables are defined in 'ini.inc.php'
//  global $hostInstitutionAbbrevName;
  $openURLResolver = variable_get('biblio_baseopenurl','');

  $co = biblio_contextObject($node); 
  $co["sid"] = "biblio:" . variable_get('site_name', 'Drupal');

  $openURL = $openURLResolver;

  if (!ereg("\?", $openURLResolver))
    $openURL .= "?";
  else
    $openURL .= "&amp;";

  $openURL .= "ctx_ver=Z39.88-2004";

  foreach ($co as $coKey => $coValue) {
    $coKey = ereg_replace("rft.", "", $coKey);
    $coKey = ereg_replace("au[0-9]*", "au", $coKey);
    $openURL .= "&amp;" . $coKey . "=" . rawurlencode($coValue);
  }

  return $openURL;
}

function biblio_coins_generate(&$node) {

  if ($node) {
      $node->biblio_coins = biblio_coins($node);
      db_query("UPDATE {biblio} SET biblio_coins = '%s' WHERE vid = %d",$node->biblio_coins,$node->vid);
  
  }else{  
    $result = db_query("SELECT nr.*, b.*  FROM {node} AS n LEFT JOIN {node_revisions}  AS nr ON n.vid = nr.vid LEFT JOIN {biblio} AS b ON n.vid = b.vid WHERE n.type = 'biblio'  ");
    while ($node = db_fetch_object($result)) {
      $node->biblio_coins = biblio_coins($node);
      db_query("UPDATE {biblio} SET biblio_coins = '%s' WHERE vid = %d",$node->biblio_coins,$node->vid);
    }
    drupal_goto('');
  }
}

function biblio_coins($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome
  // fmt_info (type)
  $fmt = "info:ofi/fmt:kev:mtx:";
  // 'dissertation' is compatible with the 1.0 spec, but not the 0.1 spec
  if ($node->biblio_type == 108)
    $fmt .= "dissertation";
  elseif ( $node->biblio_type  == 102)
    $fmt .= "journal";
  elseif ($node->biblio_type  == 100 || $node->biblio_type  == 101 )
    $fmt .= "book";
  // 'dc' (dublin core) is compatible with the 1.0 spec, but not the 0.1 spec.
  // We default to this, as it is the most generic type.
  else
    $fmt .= "dc";

  $co = biblio_contextObject($node); 

  $coins = "ctx_ver=Z39.88-2004" . "&amp;rft_val_fmt=" . urlencode($fmt);

  foreach ($co as $coKey => $coValue) {
    // 'urlencode()' differs from 'rawurlencode() (i.e., RFC1738 encoding)
    // in that spaces are encoded as plus (+) signs
    $coKey = ereg_replace("au[0-9]*", "au", $coKey);
    $coins .= "&amp;" . $coKey . "=" . urlencode($coValue);
  }

  $coinsSpan = "<span class=\"Z3988\" title=\"" . $coins . "\"></span>";

  return $coinsSpan;
}

function biblio_contextObject($node) {
  // Copyright:          Matthias Steffens <mailto:refbase@extracts.de> and the file's
  //                     original author.
  // Original Author:    Richard Karnesky <mailto:karnesky@gmail.com>  //
  // Adapted for biblio: Ron Jerome 
  global $base_url;
 // $openurl_base = variable_get('biblio_baseopenurl','');

  $co = array();

  // rfr_id
  $co["rfr_id"] = "info:sid/" . ereg_replace("http://", "", $base_url);

  // genre (type)
  if (isset($node->biblio_type )) {
    if ($node->biblio_type  == 102 )
      $co["rft.genre"] = "article";
    elseif ($node->biblio_type  == 101 )
      $co["rft.genre"] = "bookitem";
    elseif ($node->biblio_type  == 100 )
      $co["rft.genre"] = "book";
    elseif ($node->biblio_type  == "Journal")
      $co["rft.genre"] = "journal";
  }

  // atitle, btitle, title (title, publication)
  if (($node->biblio_type  == 102) || ($node->biblio_type  == 101)) {
    if (!empty($node->title ))
      $co["rft.atitle"] = $node->title ;
    if (!empty($node->biblio_secondary_title )) {
      $co["rft.title"] = $node->biblio_secondary_title ;
      if ($node->biblio_type  == 101)
        $co["rft.btitle"] = $node->biblio_secondary_title ;
    }
  }
  elseif (!empty($node->title ))
    $co["rft.title"] = $node->title ;
  if (($node->biblio_type  == 100) && (!empty($node->title )))
    $co["rft.btitle"] = $node->title ;

  // stitle (abbrev_journal)
  if (!empty($node->biblio_short_title ))
    $co["rft.stitle"] = $node->biblio_short_title ;

  // series (series_title)
  if (!empty($node->biblio_tertiary_title ))
    $co["rft.series"] = $node->biblio_tertiary_title ;

  // issn
  if (!empty($node->biblio_issn ))
    $co["rft.issn"] = $node->biblio_issn ;

  // isbn
  if (!empty($node->biblio_isbn ))
    $co["rft.isbn"] = $node->biblio_isbn ;

  // date (year)
  if (!empty($node->biblio_year ))
    $co["rft.date"] = $node->biblio_year ;

  // volume
  if (!empty($node->biblio_volume ))
    $co["rft.volume"] = $node->biblio_volume ;

  // issue
  if (!empty($node->biblio_issue ))
    $co["rft.issue"] = $node->biblio_issue ;

  // spage, epage, tpages (pages)
  // NOTE: lifted from modsxml.inc.php--should throw some into a new include file
  if (!empty($node->biblio_pages )) {
    if (ereg("[0-9] *- *[0-9]", $node->biblio_pages )) {
      list($pagestart, $pageend) = preg_split('/\s*[-]\s*/', $node->biblio_pages );
      if ($pagestart < $pageend) {
        $co["rft.spage"] = $pagestart;
        $co["rft.epage"] = $pageend;
      }
    }
    elseif ($node->biblio_type  == 100) {//"Book Whole") {
      $pagetotal = preg_replace('/^(\d+)\s*pp?\.?$/', "\\1", $node->biblio_pages );
      $co["rft.tpages"] = $pagetotal;
    }
    else
      $co["rft.spage"] = $node->biblio_pages ;
  }

  // aulast, aufirst, author (author)
  if (!empty($node->biblio_authors )) {
    $author_array = explode(";", $node->biblio_authors );
     $creators = _parse_author_array($author_array);
//     print_r($creators);
    if (!empty($creators[0]['last_name']))
      $co["rft.aulast"] = $creators[0]['last_name'];
    if (!empty($creators[0]['first_name'])) {
      $co["rft.aufirst"] = $creators[0]['first_name'];
    }elseif (!empty($creators[0]['initials'])) {
      $co["rft.aufirst"] = $creators[0]['initials'];    
    }
    // TODO: cleanup and put this function in include.inc.php?
    $authorcount = count($creators);
    for ($i=1; $i < $authorcount; $i++) {
      if (!empty($creators[$i]['last_name'])) {
        $au = $creators[$i]['last_name'];
        if (!empty($creators[$i]['first_name']) ||!empty($creators[$i]['initials']))
          $au .= ", ";
      }
      if (!empty($creators[$i]['first_name'])) {
        $au .= $creators[$i]['first_name'];
      } elseif (!empty($creators[$i]['initials'])) {
        $au .=  $creators[$i]['initials'];    
      }
      if (!empty($au))
        $co["rft.au".$i] = $au;
    }
  }

  // pub (publisher)
  if (!empty($node->biblio_publisher ))
    $co["rft.pub"] = $node->biblio_publisher ;

  // place
  if (!empty($node->biblio_place_published ))
    $co["rft.place"] = $node->biblio_place_published ;

  // id (doi, url)
  if (!empty($node->biblio_doi ))
    $co["rft_id"] = "info:doi/" . $node->biblio_doi ;
  elseif (!empty($node->biblio_url ))
    $co["rft_id"] = $node->biblio_url ;
  return $co;
}

function _biblio_get_user_pubs($user,$profile=''){
    switch ((isset($user->biblio_profile_uid) ) ? $user->biblio_profile_uid : variable_get('biblio_profile_uid', 'uid')){
    case 'lastname':
      $pubs = biblio_db_search('author', $user->biblio_lastname, $profile);
      break;
    case 'uid_lastname':
      $pubs = biblio_db_search('uid', $user->uid, 'author', $user->biblio_lastname, $profile);
    break;
    case 'uid':
    default:
      $pubs = biblio_db_search('uid', $user->uid, $profile);
    }
  return $pubs;
  
}

function biblio_form_sort($a, $b) {
  $a_weight = (is_array($a) && isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (is_array($b) && isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}
