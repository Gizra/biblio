<?php
/**
 *   biblio.module for Drupal
 *
 *   Copyright (C) 2006-2011  Ron Jerome
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this program; if not, write to the Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */

/**
 * Implements hook_access().
 */
function biblio_access($op, $node = '') {
  global $user;

  switch ($op) {
    case 'admin':
      return user_access('administer biblio');
    case 'import':
      return user_access('import from file');
    case 'export':
      return user_access('show export links');
    case 'edit_author':
        if (user_access('administer biblio') || user_access('edit biblio authors')) return NODE_ACCESS_ALLOW;
        break;
    case 'download':
      if (user_access('show download links') || (user_access('show own download links') && ($user->uid == $node->uid))) return NODE_ACCESS_ALLOW;
      break;
    case 'rss':
      return variable_get('biblio_rss', 0);
    default:
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_permission().
 *
 * Since we are limiting the ability to create new nodes to certain users,
 * we need to define what those permissions are here. We also define a permission
 * to allow users to edit the nodes they created.
 */
function biblio_permission() {
  return array(
    'administer biblio' => array(
      'title' => t('Administer Biblio'),
      'description' => t('Allows full control (create, update, delete) of all Biblio nodes'),
    ),
    'access biblio content' => array(
      'title' => t('Access Biblio content'),
      'description' => t('Allows the user to view Biblio nodes'),
    ),
   'create biblio' => array(
     'title' => t('Create Biblio'),
     'description' => t('Allows the user to create new Biblios'),
   ),
   'edit all biblio entries' => array(
     'title' => t('Edit all Biblio entries'),
     'description' => t('Allows the user to edit ALL biblio entries regardless of who "owns" them, otherwise they are restricted to on'),
   ),
    'delete biblios' => array(
      'title' => t('Delete Biblios'),
      'description' => t('Allows the user to delete any biblio entities'),
    ),
    'edit by all biblio authors' => array(
      'title' => t('Edit by all Biblio authors'),
      'description' => t('Allows any/all of the authors associated with a biblio entry to edit the biblio entry. This requires the Drupal UserID be mapped to a Biblio author ID'),
    ),
    'edit biblio authors' => array(
      'title' => t('Edit Biblio authors'),
      'description' => t('Allows the user to edit author information'),
    ),
    'manage biblio structure' => array(
      'title' => t('Manage Biblio structure'),
      'description' => t('This determines if the user will be able to modify field and display settings for biblio and contributor entities (admin/structure/biblio)'),
    ),
    'manage biblio content' => array(
      'title' => t('Manage Biblio content'),
      'description' => t('This determines if the user will be able to access the managment interface for biblios and contributors (admin/content/biblio)'),
    ),
  );
}


/**
 * Removes brace from a string
 *
 * @param string $title_string
 * @return string
 */
function biblio_remove_brace($title_string) {
    //$title_string = utf8_encode($title_string);
    $matchpattern = '/\{\$(?:(?!\$\}).)*\$\}|(\{[^}]*\})/';
    $output = preg_replace_callback($matchpattern, 'biblio_remove_brace_callback', $title_string);
    return $output;
}

/**
 * Callback from preg_replace_callback
 *
 * @param array $match
 * @return array
 */
function biblio_remove_brace_callback($match) {
  if (isset($match[1])) {
    $braceless = str_replace('{', '', $match[1]);
    $braceless = str_replace('}', '', $braceless);
    return $braceless;
  }
  return $match[0];
}

/**
 * Implements hook_ctools_plugin_api().
 */
function biblio_ctools_plugin_api($module, $api) {
  if ($module == 'biblio' && $api == 'biblio_style') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_ctools_plugin_type().
 */
function biblio_ctools_plugin_type() {
  $plugins['biblio_style'] = array(
    'classes' => array('class'),
    'process' => 'biblio_plugin_process',
  );
  return $plugins;
}


/**
 * Add defaults values to the notifier plugins.
 *
 * - 'description': The description of the plugin.
 */
function biblio_plugin_process(&$plugin, $info) {
  $plugin += array(
    'description' => '',
    'options' => array(),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function biblio_ctools_plugin_directory($module, $plugin) {
  if ($module == 'biblio') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Helper function to include CTools plugins and get a notifier plguin.
 *
 * @param $plugin_name
 *   The plugin that should be laoded.
 */
function biblio_get_biblio_style($style_name) {
  ctools_include('plugins');
  return ctools_get_plugins('biblio', 'biblio_style', $style_name);
}

/**
 * Helper function to include CTools plugins and get all notifier plugins.
 */
function biblio_get_biblio_styles() {
  ctools_include('plugins');
  return ctools_get_plugins('biblio', 'biblio_style');
}

/**
 * Helper function to return all notifiers as options for a select list.
 */
function biblio_get_notifiers_as_options() {
  $options = array();
  foreach (biblio_get_biblio_styles() as $style_name => $style) {
    $options[$style_name] = check_plain($style['title']);
  }

  return $options;
}

/**
 * Implements hook_views_api().
 */
function biblio_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'biblio') . '/views',
  );
}
/**
 * Implements hook_entity_info().
 *
 * Inform the Drupal and the Field API about entity types.
 * Uses the contrib Entity API module to create entities
 */
function biblio_entity_info() {
  $return['biblio'] = array(
    'label' => t('Biblio'),
    'entity class' => 'Biblio',
    'controller class' => 'EntityAPIController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'biblio',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'bid',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'load hook' => 'biblio_load',
    'view modes' => array(),
    // Entity API label callback that takes a look at our entity class method defaultLabel()
    'label callback' => 'entity_class_label',
    // This is also a standard Entity API callback for uri.
    // It executes our entity defaultUri() method
    'uri callback' => 'entity_class_uri',
    'module' => 'biblio',
    'access callback' => 'biblio_entity_access',
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  if (db_table_exists('biblio')) {
    $biblio_types = db_select('biblio', 'b')
      ->fields('b')
      ->execute()
      ->fetchAllAssoc('type');
  }

  if (!empty($biblio_types)) {
    foreach ($biblio_types as $type => $info) {
      $return['biblio']['bundles'][$type] = array(
        'label' => $info->name,
        'admin' => array(
          // defines the path that should be used in hook_menu() for the Fields UI pages
          'path' => 'admin/structure/biblio/publication-types/%biblio_bundle',
          // The exact path that should be used when generating links within the admin interface
          'real path' => 'admin/structure/biblio/publication-types/' . str_replace('_', '-', $type),
          // menu args are 0 based, so  is the seventh part of the path, which
          // here is %biblio_bundle.
          'bundle argument' => 4,
          'access arguments' => array('manage biblio structure'),
        ),
      );
    }
  }

  $return['biblio_contributor'] = array(
    'label' => t('Contributor'),
    'entity class' => 'BiblioContributor',
    'controller class' => 'EntityAPIController',
    'base table' => 'biblio_contributor',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'cid',
      'bundle' => 'type',
      'label' => 'name',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    // @todo: possibly figure out a better bundle name and/or figure out what
    // bundles we can have for contributors
    'bundles' => array(),
    'load hook' => 'biblio_contributor_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'biblio',
    'access callback' => 'biblio_entity_access',
  );


  return $return;
}

/**
 * Gets all publication types that are set up by default.
 * @return type
 *
 * @todo: Fix.
 */
function biblio_types($entity_type = FALSE) {
  return;
    $query = db_select('biblio', 'bt')
        ->fields('bt', array('name', 'description', 'entity'));

    if ($entity_type) {
      $query->condition('entity', $entity_type);
    }

    $result = $query->execute();

    $entity_type_passed_in = $entity_type;
    while ($row = $result->fetchAssoc()) {
      if ($entity_type_passed_in === FALSE) {
        $entity_type = $row['entity'];
      }
      $bundle_name = biblio_bundle_name($entity_type);
      // computer-friendly version of the human-readable content type stored in the database
      $machine_name = str_replace(' ', '_', strtolower($row['name']));

      $types[$machine_name] = (object)array(
        // type is the machine name of the bundle
        $bundle_name => $machine_name,
        'entity' => $row['entity'],
        // name is the human name of the bundle
        'name' => t($row['name']),
        'description' => t($row['description']),
      );

    }

  return $types;
}

/**
 * Access callback for the entity API.
 */
function biblio_entity_access($op, $type = NULL, $account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('administer biblio', $account)
          || user_access('create biblio', $account);
    case 'view':
      return user_access('administer biblio', $account)
          || user_access('access biblio content', $account);
    case 'delete':
    case 'edit':
      return user_access('administer biblio')
          || user_access('edit all biblio entries');
  }
}

function biblio_bundle_load($type) {
  return biblio_combined_bundle_load($type);
}

function contributor_bundle_load($type) {
  return biblio_combined_bundle_load($type);
}

/**
 * Create a biblio entity object
 *
 * @param $type
 *  The publication type of the biblio to be created (bundle)
 * @param array $values
 *  An associative array of any additional values to be set when creating this
 *  entity. These values will be carried throughout the biblio object's life.
 *  Example: $values['language'] => 'en';
 * @return object The biblio object, with default values.
 */
function biblio_create($type, $values = array()) {
  global $language;
  if (empty($account)) {
    global $user;
    $account = clone $user;
  }
  $values['type'] = $type;
  $values['uid'] = $account->uid;
  $values += array(
    'language' => $language->language,
    'created' => REQUEST_TIME,
    'changed' => REQUEST_TIME,
  );

  $values['type'] = $type;
  return entity_create('biblio', $values);
}

/**
 * Load a biblio object from the database.
 *
 * @param $bid
 *   The biblio ID.
 * @param $reset
 *   Whether to reset the biblio_load_multiple cache.
 *
 * @return
 *   A fully-populated node object.
 */
function biblio_load($bid) {
  return entity_load_single('biblio', $bid);
}

/**
 * Load biblio entities from the database.
 *
 * This function should be used whenever you need to load more than one biblio
 * from the database. biblios are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @see entity_load()
 *
 * @param $bids
 *   An array of biblio IDs.
 * @param $conditions
 *   An array of conditions on the {biblio} table in the form 'field' => $value.
 * @param $reset
 *   Whether to reset the internal entity_load cache.
 *
 * @return
 *   An array of biblio objects indexed by bid.
 */
function biblio_load_multiple($bids = array()) {
  return entity_load('biblio', $bids);
}


/**
 * Create a contributor entity object
 * @param  string $name   (optional) The name of the contributor. If given, this
 *                        function will parse out the author name and
 *                        automatically fill in any associated fields (first
 *                        name, last name, initials, etc.) and the type
 * @param  string $type   (optional) The contributor type (bundle) of the
 *                        contributor entity to create. ex: 'person' or
 *                        'organization'. Leave null to let this function parse
 *                        the name (if passed in) and auto-generate the type.
 * @param  array  $values (optional)
 * @return object         The contributor entity object
 */
function biblio_contributor_create($name , $type, $values = array()) {
  global $language;

  $values['name'] = $name;
  $values['type'] = $type;
  $values += array(
    'language' => $language->language,
    'created' => REQUEST_TIME,
    'changed' => REQUEST_TIME,
  );

  $values['type'] = $type;
  return entity_create('biblio_contributor', $values);
}

/**
 * Load a contributor.
 */
function biblio_contributor_load($cid) {
  return entity_load_single('biblio_contributor', $cid);
}

/**
 * Load multiple contributors based on certain conditions.
 */
function biblio_contributor_load_multiple($cids = array()) {
  return entity_load('biblio_contributor', $cids);
}

/**
 * Implements hook_entity_property_info_alter().
 */
function biblio_entity_property_info_alter(&$info) {
  $properties = &$info['biblio']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the biblio was added."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'description' => t("The date the biblio was most recently changed/edited."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'changed',
  );
  $properties['uid'] = array(
    'label' => t("Author"),
    'type' => 'user',
    'description' => t("The creator of the biblio entity."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'required' => TRUE,
    'schema field' => 'uid',
  );
  $properties['biblio_sort_title'] = array(
    'label' => t("Sort Title"),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'biblio_sort_title',
  );

  $properties = &$info['biblio_contributor']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the contribtuor was added."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'description' => t("The date the contributor was most recently changed/edited."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'changed',
  );
  $properties['md5'] = array(
    'label' => t("MD5"),
    'description' => t("MD5 of the contributor. Used for resolving duplicates"),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'edit all biblio entries',
    'schema field' => 'md5',
  );
}

/**
 * Create an biblio field in a bundle.
 *
 * @param $field_name
 *   The field name
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The bundle name.
 * @param $og_field
 *   Optional; Array with field definitions, to allow easier overriding by the
 *   caller. If empty, function will get the field info by calling
 *   og_fields_info() with the field name.
 */
function biblio_create_field($field_name, $entity_type, $bundle, $biblio_field = array()) {
  if (empty($biblio_field)) {
    $biblio_field = biblio_fields_info($field_name);
  }

  $field = field_info_field($field_name);
  // Allow overriding the field name.
  $biblio_field['field']['field_name'] = $field_name;
  if (empty($field)) {
    field_create_field($biblio_field['field']);
  }

  $instance = field_info_instance($entity_type, $field_name, $bundle);
  if (empty($instance)) {
    $instance = $biblio_field['instance'];
    $instance += array(
      'field_name' => $field_name,
      'bundle' => $bundle,
      'entity_type' => $entity_type,
    );

    field_create_instance($instance);
    entity_property_info_cache_clear();
  }
}


/**
 * Get the field info.
 *
 * @param $field_name
 *  The field name.
 *
 * @return
 */
function biblio_fields_info($field_name = NULL) {
  $fields = _biblio_fields_info();

  if (!empty($fields)) {
    return !empty($fields[$field_name]) ?  $fields[$field_name] : FALSE;
  }

  return $fields;
}

/**
 * Biblio fields information.
 */
function _biblio_fields_info() {
  $items['biblio_publication_year'] = array(
    'type' => array('biblio'),
    'description' => 'Publication year.',
    'field' => array(
      'cardinality' => '1',
      'entity_types' => array(),
      'field_name' => 'biblio_publication_year',
      'module' => 'number',
      'type' => 'number_integer',
    ),
    'instance' => array(
      'label' => 'Publication year',
      'description' => 'The year of the publication.',
      'display_label' => 1,
      'widget' => array(
        'active' => 0,
        'module' => 'number',
        'settings' => array(),
        'type' => 'number',
        'weight' => '2',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'type' => 'og_group_subscribe',
          'custom settings' => FALSE,
        ),
      ),
    ),
  );

  $items['biblio_publication_abstract'] = array(
    'type' => array('biblio'),
    'description' => 'Publication abstract data.',
    'field' => array(
      'cardinality' => '1',
      'entity_types' => array(),
      'field_name' => 'biblio_publication_abstract',
      'module' => 'text',
      'type' => 'text_long',
    ),
    'instance' => array(
      'label' => 'Publication abstract',
      'description' => 'Holds generic info the biblio.',
      'widget' => array(
        'active' => 1,
        'module' => 'text',
        'settings' => array(
          'rows' => '5',
        ),
        'type' => 'text_textarea',
        'weight' => '-1',
      ),
    ),
  );

  $items['biblio_publication_image'] = array(
    'type' => array('biblio'),
    'description' => 'Image for the biblio entry.',
    'field' => array(
      'cardinality' => '1',
      'field_name' => 'biblio_publication_image',
      'locked' => '0',
      'module' => 'image',
      'settings' => array(
        'default_image' => 0,
        'uri_scheme' => 'public',
      ),
      'translatable' => '0',
      'type' => 'image',
    ),
    'instance' => array(
      'label' => 'The publication image',
      'description' => 'Image for the biblio',
      'settings' => array(
        'alt_field' => 0,
        'default_image' => 0,
        'file_directory' => '',
        'file_extensions' => 'png gif jpg jpeg',
        'max_filesize' => '',
        'max_resolution' => '',
        'min_resolution' => '',
        'title_field' => 0,
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 1,
        'module' => 'image',
        'settings' => array(
          'preview_image_style' => 'thumbnail',
          'progress_indicator' => 'throbber',
        ),
        'type' => 'image_image',
        'weight' => '-2',
      ),
    ),
  );

  $items['biblio_publication_pages'] = array(
    'type' => array('biblio'),
    'description' => 'First & last page numbers of the piece. e.g. 23-25.',
    'field' => array(
      'cardinality' => '1',
      'field_name' => 'biblio_publication_pages',
      'module' => 'text',
      'settings' => array(
        'max_length' => '255',
      ),
      'translatable' => '0',
      'type' => 'text',
    ),
    'instance' => array(
      'label' => 'Publication pages',
      'description' => 'First & last page numbers of the piece. e.g. 23-25',
      'settings' => array(
        'text_processing' => '0',
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 1,
        'module' => 'text',
        'settings' => array(
          'size' => '60',
        ),
        'type' => 'text_textfield',
        'weight' => '-3',
      ),
    ),
  );

  $items['contributor_field_collection'] = array(
    'field' => array(
      'cardinality' => '1',
      'field_name' => 'contributor_field_collection',
      'foreign keys' => array(),
      'indexes' => array(),
      'locked' => '0',
      'module' => 'field_collection',
      'settings' => array(
        'hide_blank_items' => 1,
        'path' => '',
      ),
      'translatable' => '0',
      'type' => 'field_collection',
    ),
    'instance' => array(
      'label' => 'Field collection',
      'required' => 0,
      'settings' => array(
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 0,
        'module' => 'field_collection',
        'settings' => array(),
        'type' => 'field_collection_embed',
        'weight' => 0,
      ),
    ),
  );

  $items['biblio_contributor_reference'] = array(
    'field' => array(
      'active' => '1',
      'cardinality' => '1',
      'deleted' => '0',
      'entity_types' => array(),
      'field_name' => 'biblio_contributor_reference',
      'module' => 'entityreference',
      'settings' => array(
        'handler' => 'base',
        'handler_settings' => array(
          'sort' => array(
            'type' => 'none',
          ),
          'target_bundles' => array(),
        ),
        'target_type' => 'biblio_contributor',
      ),
      'translatable' => '0',
      'type' => 'entityreference',
    ),
    'instance' => array(
      'label' => 'Contributor reference',
      'required' => 0,
      'settings' => array(
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 1,
        'module' => 'entityreference',
        'settings' => array(
          'match_operator' => 'CONTAINS',
          'path' => '',
          'size' => '60',
        ),
        'type' => 'entityreference_autocomplete',
        'weight' => '1',
      ),
    ),
  );

  $items['biblio_contributor_roles'] = array(
    'field' => array(
      'cardinality' => '1',
      'field_name' => 'biblio_contributor_roles',
      'foreign keys' => array(),
      'module' => 'list',
      'settings' => array(
        'allowed_values' => array(
          'author' => 'Author',
          'editor' => 'Editor',
        ),
        'allowed_values_function' => '',
      ),
      'type' => 'list_text',
    ),
    'instance' => array(
      'label' => 'Contributor roles',
      'required' => 0,
      'settings' => array(
        'user_register_form' => FALSE,
      ),
      'widget' => array(
        'active' => 1,
        'module' => 'options',
        'settings' => array(),
        'type' => 'options_select',
        'weight' => '2',
      ),
    ),
  );

  return $items;
}
