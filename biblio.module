<?php
// $Id$ 
/** 
 *   biblio.module for Drupal
 *    
 *   Copyright (C) 2006  Ron Jerome
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation; either version 2 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License along
 *   with this program; if not, write to the Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 */  
function biblio_autocomplete($field,$string=''){
    $matches = array();
    $result = db_query_range("SELECT $field FROM {biblio} WHERE LOWER($field) LIKE LOWER('%s%%') ORDER BY $field ASC", $string, 0, 10);
    while ($data = db_fetch_object($result)) {
      $matches[$data->$field] = check_plain($data->$field);
    }
    print drupal_to_js($matches);
    exit();
}
function biblio_help_page() {
  $base =  variable_get('biblio_base', 'biblio');
  
  $text .= "<H3>".t('General: ')."</H3>";
  $text .= t('By default, the ').l('',$base).
           t(' page will list all of the entries in the database sorted by Year in descending order. If you wish to sort by "Title" or "Type",  you may do so by clicking on the appropriate links at the top of the page.  To reverse the sort order, simply click the link a second time.');
  $text .= "<H3>".t('Filtering Search Results:')."</H3><P>";
  $text .= t('If you wish to filter the results, click on the "Filter" tab at the top of the page.  To add a filter, click the radio button to the left of the filter type you wish to apply, then select the filter criteria from the drop down list on the right, then click the filter button.');
  $text .= "</P><P>";
  $text .= t('It is possible to create complex filters by returning to the ');
  $text .= "<i>".t('"Filter"')."</i>";
  $text .= t(' tab and adding additional filters.  Simply follow the steps outlined above and press the "Refine" button.')."</P>";
  $text .= "<P>".t('All filters can be removed by clicking the ')."<I>".
              t('"Clear All Filters"')."</I>".
              t('link at the top of the result page, or on the ')."<i>".
              t('"Filter"')."</i>". 
              t(' tab they can be removed one at a time using the ')."<i>".t('"Undo"')."</i>".
              t(' button, or you can remove them all using the ')."<i>".t('"Clear All"')."</i>".
              t(' button.')."</P>";
  $text .= "<P>".t('You may also construct URLs which filter.  For example, /biblio/year/2005 will show all of the entries for 2005.  /biblio/year/2005/author/smith will show all of entries from 2005 for smith.')."</P>";
  $text .= "<H3>".t('Exporting Search Results:')."</H3>";
  $text .= "<P>".t('Assuming this option has been enabled by the administrator, you can export search results directly into EndNote.  The link at the top of the result page will export all of the search results, and the links on individual entries will export the information related to that single entry.')."</P>";
  $text .= "<P>".t('The information is exported in EndNote "Tagged" format similar to this...').
              "<pre>". t('
              %0  Book
              %A  John Smith 
              %D  1959
              %T  The Works of John Smith
              ...').'
              </pre></P>';
  $text .= "<P>".t('Clicking on one of the export links should cause your browser to ask you whether you want to Open, or Save To Disk, the file endnote.enw.  If you choose to open it, Endnote should start and ask you which library you would like store the results in.  Alternatively, you can save the file to disk and manually import it into EndNote.')."</P>";

  print theme('page', $text);
} 

/**
* Implementation of hook_help().
* 
* Throughout Drupal, hook_help() is used to display help text at the top of
* pages. Some other parts of Drupal pages get explanatory text from these hooks
* as well. We use it here to provide a description of the module on the
* module administration page.
*/

function biblio_help($section) {
  switch ($section) {
    case 'admin/modules#description': 
      // This description is shown in the listing at admin/modules.
      return t('Manages a list of scholarly papers on your site');
    case 'node/add#biblio': 
      // This description shows up when users click "create content."
      return t('This allows you to add a bibliographic entry to the database');
  } 
} 

function biblio_node_info() {
  return array('biblio' => array(
                    'name' => t('biblio'), 
                    'module' => 'biblio',
                    'description' => t('Maintains list of bibliographies')));
}


/**
* Implementation of hook_access().
* 
* Node modules may implement node_access() to determine the operations
* users may perform on nodes. This example uses a very common access pattern.
*/
function biblio_access($op, $node) {
  global $user;

  if ($op == 'create') {
    // Only users with permission to do so may create this node type.
    return user_access('create biblio');
  } 
  if ($op == 'import') {
    // Only users with permission to do so may import entries from file.
    return user_access('import from file');
  } 
  if ($op == 'export') {
    // Only users with permission to do so may export entries from file.
    return user_access('show export links');
  } 
  // Users who create a node may edit or delete it later, assuming they have the
  // necessary permissions.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('edit own biblio entries') && ($user->uid == $node->uid)) {
      return true;
    }else{
      return false;
    } 
  }
  if ($op == 'view'){
    if (variable_get('biblio_view_only_own', 0) ){
       if (  $user->uid == $node->uid ) {
         return true;
       }else{
         return false;
       }
    }else{
       return true;
    }
  } 
} 

/**
* Implementation of hook_perm().
* 
* Since we are limiting the ability to create new nodes to certain users,
* we need to define what those permissions are here. We also define a permission
* to allow users to edit the nodes they created.
*/
function biblio_perm() {
  return array('create biblio', 'edit own biblio entries', 'import from file','show export links','show filter tab','show sort links');
} 
/**
* Implementation of hook_link().
* 
* This is implemented so that an edit link is displayed for users who have
* the rights to edit a node.
*/
function biblio_link($type, $node = 0, $main) {
  $links = array();

  if ($type == 'node' && $node->type == 'biblio') {
    // Don't display a redundant edit link if they are node administrators.
    if (biblio_access('update', $node) && !user_access('administer nodes')) {
      $links[] = l(t('edit this entry'), "node/$node->nid/edit");
    } 
  } 

  return $links;
} 
/**
* Implementation of hook_settings().
*/
function biblio_settings() {
  $form['biblio_base'] = array(
    '#type' => 'textfield',
    '#title' => t('Base URL'),
    '#size' => 20,
    '#default_value' => variable_get('biblio_base', 'biblio'),
    '#description' =>  t('This sets the base URL used to access the biblio module (e.g. /biblio ).'),
  );
  $form['biblio_rowsperpage'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of results per page.'),
    '#default_value' => variable_get('biblio_rowsperpage', 25),
    '#size' => 6,
    '#maxlength' => 6,
    '#description' => t('This sets the number of results that will be displayed per page.'),
  );
  $form['biblio_normalize'] = array(
    '#type' => 'checkbox',
    '#title' => t('Normalize author names when displaying biblio records'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_normalize', 0),
    '#description' => t('Tries (doesn\'t always work) to reformat author names so that they are displayed in the format "Lastname, Initials" e.g. Smith, J.S. (Note: This setting does not modify the entry in the database, it only reformats it\'s presentation. This option can be turned off at any time to diplay the oringal format.)'), );
  $form['biblio_view_only_own'] = array(
    '#type' => 'checkbox',
    '#title' => t('Restrict users such that they can only view their own biblio entries'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_view_only_own', 0),
    '#description' => t('This option restricts the users capability to view biblio entries.  They will only be able to see the entries which they have created and own.') );
  $form['sort'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Sorting'),
    '#description' => t('You can set the default sorting and ordering for the /biblio page here.'),
  );
  $form['sort']['biblio_sort'] = array(
    '#type' => 'radios',
    '#title' => t('Sort by'),
    '#default_value' => variable_get('biblio_sort', 'year'),
    '#options' => array('author'=>t('Author'), 'title'=>t('Title'),'type'=>t('Type'),'year'=>t('Year')),
  );
  $form['sort']['biblio_order'] = array(
    '#type' => 'radios',
    '#title' => t('Order'),
    '#default_value' => variable_get('biblio_order', 'DESC'),
    '#options' => array('DESC'=>t('Descending'), 'ASC'=>t('Ascending')),
  );
  $form['style'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Styling'),
    '#description' => t('You can set the default style for the /biblio page here.'),
  );
  $form['style']['biblio_node_layout'] = array(
    '#type' => 'radios',
    '#title' => t('Node Layout'),
    '#default_value' => variable_get('biblio_node_layout', '0'),
    '#options' => array('orig'=>t('Original'), 'ft'=>t('Only Fulltext if available')),
    '#description' => t('This alters the layout of the "node" (full) view.'),
  );
  $form['style']['biblio_style'] = array(
    '#type' => 'radios',
    '#title' => t('Style'),
    '#default_value' => variable_get('biblio_style', 'classic'),
    '#options' => _biblio_get_styles(),
    '#description' => t('This alters the layout of the "list" (short) view.'),
  );
  $form['syndication'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Syndication'),
    '#description' => t('You can set the RSS defaults here.'),
  );
  $form['syndication']['biblio_rss'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow RSS feeds of new biblio entries'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_rss', 0),
    '#description' => t('The will create an rss feed of the 10 most recent biblio entries. It will be available at /biblio/rss.xml'), 
  );

  $form['taxo'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Taxonomy'),
    '#description' => t('You can set the Taxonomy defaults here.'),
  );
  $form['taxo']['biblio_keyword_freetagging'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use keywords from biblio entries as taxonomy "free tags"'),
    '#return_value' => 1,
    '#default_value' => variable_get('biblio_keyword_freetagging', 0),
    '#description' => t('This option allows user to add keywords (free tags) to describe their documents. These keywords will be registered as taxonomy.'),
   );
  $vocabularies = module_invoke('taxonomy', 'get_vocabularies');
   // ... and print a form to select the terms in each of them
  $choice = new stdClass();
  $choice->option = array(0 =>  '<'. t('none') .'>');
  $options[0] = $choice;
  if (count($vocabularies)){
    foreach ($vocabularies as $voc) {
        $choice = new stdClass();
        $choice->option = array($voc->vid =>  $voc->name);
        $options[] = $choice;
    }
  
    $form['taxo']['biblio_freetagging_vocab'] = array('#type' => 'select',
    '#title' => t('Vocabulary'),
    '#default_value' => variable_get('biblio_freetagging_vocab', 0),
    '#options' => $options,
    '#description' => t('Select vocabulary (category) to use for free tags.'),
    '#multiple' => FALSE,
    '#disabled' => (!variable_get('biblio_keyword_freetagging', 0)),
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => 15,
    );

  }
  menu_rebuild();

  return system_settings_form($form);
} 

/*  This function parses the module directory for 'style' files, loads them and
 *  calls the info fuction to get some basic information like the short and long
 *  names of the style
*/   
function _biblio_get_styles(){
  $styles = array();
  $dir    = drupal_get_path('module', 'biblio');
  $files  = array();
  if ($dh = opendir($dir)) {
    while (($files[] = readdir($dh)) !== false) {
    }
    closedir($dh);
    foreach ($files as $file){
      if (strstr ( $file, 'biblio_style_')){ //find the style files
        include_once $dir."/".$file;          
        if (function_exists(basename($file, ".inc").'_info')){
          $styles = array_merge($styles, call_user_func(basename($file, ".inc").'_info')); //build and array of the short and long names
        }
      }
    }
  }
  return($styles);
}
/**
* Implementation of hook_menu().
* 
* Here we define some built in links for the biblio module, links exposed are:
*   /node/add/biblio      => to add a single entry
*   /biblio               => lists all entries in the biblio database
*   /biblio/list          => default local task for /biblio
*   /biblio/filter        => local task which allows users to add filters to their query
*   /biblio/filter/clear  => used internally to remove all filters
*   /biblio/help          => displays a help page
*   /biblio/export/endnote => used to export information in Endnote Tagged format
*   /biblio/import/form   => presents a form to allow the user to upload a file to import
*    
*   
*/
function biblio_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'node/add/biblio', 'title' => t('bibliography'),
      'access' => user_access('create biblio'));
    // The next two "LOCAL TASKS" are for the admin/settings/biblio page  
    $items[] = array('path' => 'admin/settings/biblio', 'title' => t('Biblio settings'),
      'description' => t('Configure default behavior of the biblio module.'),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_settings'));
    $items[] = array('path' => 'admin/settings/biblio/basic', 'title' => t('Preferences'),
      'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => -10);
    $items[] = array('path' => 'admin/settings/biblio/import', 'title' => t('File Import'),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_import'),
      'type' => MENU_LOCAL_TASK, 'weight' => -7);  
    $items[] = array('path' => 'admin/settings/biblio/types', 'title' => t('Type Customization'),
      'callback' => 'biblio_form_types',
      'type' => MENU_LOCAL_TASK, 'weight' => -8);  
    $items[] = array('path' => 'admin/settings/biblio/defaults', 'title' => t('Type Defaults'),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_types_edit'),
      'type' => MENU_LOCAL_TASK , 'weight' => -9);  
    $items[] = array('path' => 'admin/settings/biblio/types/add', 'title' => t(''),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_types_add'),
       'type' => MENU_CALLBACK );  
    $items[] = array('path' => 'admin/settings/biblio/types/edit', 'title' => t(''),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_types_edit'),
       'type' => MENU_CALLBACK );  
    $items[] = array('path' => 'admin/settings/biblio/types/delete', 'title' => t(''),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_types_delete'),
      'type' => MENU_CALLBACK );  
    $items[] = array('path' => 'admin/settings/biblio/types/new', 'title' => t('Add New Type'),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_types_add'),
      'type' => MENU_LOCAL_TASK, 'weight' => -9);  
    $items[] = array('path' => 'admin/settings/biblio/types/reset', 'title' => t('Reset all types to defaults '),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_types_reset'),
      'type' => MENU_LOCAL_TASK );  
    $items[] = array('path' => 'admin/settings/biblio/types/hide', 'title' => t(''),
      'callback' => 'biblio_types_hide',
      'type' => MENU_CALLBACK );  
    $items[] = array('path' => 'admin/settings/biblio/types/show', 'title' => t(''),
      'callback' => 'biblio_types_show',
      'type' => MENU_CALLBACK );  
    $items[] = array('path' => 'biblio/autocomplete',
      'title' => t('Autocomplete '),
      'callback' => 'biblio_autocomplete',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
  } 
  $base =  variable_get('biblio_base', 'biblio');
  $items[] = array('path' => $base, 'title' => t(''),
      'callback' => 'biblio_db_search',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
  $items[] = array('path' => "$base/list", 'title' => t('List'),
      'type' => MENU_DEFAULT_LOCAL_TASK, 'weight' => -10);
  $items[] = array('path' => "$base/filter", 'title' => t('Filter'),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_filter'),
      'access' => user_access('show filter tab'),
      'type' => MENU_LOCAL_TASK, 'weight' => -9);
  $items[] = array('path' =>  "$base/filter/clear", 'title' => t(''),
      'callback' => 'biblio_filter_clear',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
  $items[] = array('path' => "$base/help", 'title' => t('Help'),
      'callback' => 'biblio_help_page',
      'access' => user_access('access content'),
      'type' => MENU_CALLBACK);
  $items[] = array('path' => "$base/import/form", 'title' => t(''),
      'callback' => 'drupal_get_form', 'callback arguments' => array('biblio_form_import'),
      'access' => user_access('import from file'),
      'type' => MENU_CALLBACK);
  $items[] = array('path' => "$base/export", 'title' => t(''),
      'callback' => '_biblio_export',
      'access' => user_access('show export links'),
      'type' => MENU_CALLBACK);
    $items[] = array('path' => "$base/type/add", 'title' => t(''),
      'callback' => 'biblio_type_add',
      'type' => MENU_CALLBACK);
    $items[] = array('path' => "$base/type/remove", 'title' => t(''),
      'callback' => 'biblio_type_remove',
      'type' => MENU_CALLBACK);
    $items[] = array('path' => "$base/citekey", 'title' => t(''),
      'callback' => 'biblio_citekey_view',
      'type' => MENU_CALLBACK);

    if (variable_get('biblio_rss', 0)){
      $items[] = array('path' => "$base/rss.xml", 'title' => t('RSS feed'),
        'callback' => 'biblio_feed',
        'access' => user_access('access content'),
        'type' => MENU_CALLBACK);
    }
  return $items;
} 
function biblio_form_types_add(){
    $form['type_name'] = array('#type'=>'textfield',
                          '#title'=>t('Type Name'),
                          '#size'=>20,
                          '#weight'=>1,
                          '#required'=>true,
                          '#maxlength'=>64);
    $form['type_description'] = array('#type'=>'textfield',
                                 '#title'=>t('Description'),
                                 '#size'=>60,
                                 '#weight'=>2,
                                 '#maxlength'=>255);
    $form['type_button'] = array('#type' => 'submit', 
                    '#value' => t('Create New Type'),
                    '#weight'=>3);
    return $form;
}

function biblio_form_types_add_submit($form_id, $edit){

   $tid =  variable_get('biblio_max_user_tid', '999') + 1;
   $query = "INSERT INTO {biblio_types} (`name`,`description`,`tid`) VALUES ('%s', '%s','%d')";
   db_query($query,$edit['type_name'],$edit['type_description'],$tid);
   variable_set('biblio_max_user_tid',$tid);
   drupal_goto('admin/settings/biblio/types');

}
function biblio_types_hide(){
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('UPDATE {biblio_types} SET visible = 0 WHERE tid = %d ', $args[0]);
 }
 drupal_goto('admin/settings/biblio/types');
}
function biblio_types_show(){
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('UPDATE {biblio_types} SET visible = 1 WHERE tid = %d ', $args[0]);
 }
 drupal_goto('admin/settings/biblio/types');
}
function biblio_form_types_delete(){
 $args = func_get_args();
 if ($args[0] > 0 && is_numeric($args[0]) ) {
    $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid = %d ', $args[0]);
    $row = db_fetch_array($result);
    $result = db_query('SELECT b.* FROM {biblio} as b WHERE b.biblio_type = %d',$row['tid']);
    if ($num_rows = db_num_rows($result)){
      $existing_msg = 'There are '.$num_rows.' biblio entries of this type, you should change the type of these entries before proceeding otherwise they will be deleted';
    }
    
    $form['tid'] = array('#type' => 'value', '#value' => $row['tid']);
    $output = confirm_form( $form,
           t('Are you sure you want to delete the custom biblio type:  %title ? ', array('%title'=>$row['name'])).$existing_msg,
           $_GET['destination'] ? $_GET['destination'] : 'admin/settings/biblio/types', t('This action cannot be undone.'),
           t('Delete'), t('Cancel')  );
  
    return $output;                
  }else{
    drupal_goto('admin/settings/biblio/types');  
  }
}
function biblio_form_types_delete_submit($form_id, $edit){

  if ($form_id = "biblio_form_types_delete" ){
    db_query('DELETE FROM {biblio_types} WHERE tid = %d', $edit['tid']);
  }   
    drupal_goto('admin/settings/biblio/types');  
}
function biblio_form_types(){

  $result = db_query('SELECT t.* FROM {biblio_types as t WHERE t.tid > 0}');
  //$rows[] = array('',t('Fields Common To All Types'),l('edit', 'admin/settings/biblio/types/edit'),'');

  while ($row = db_fetch_object($result)) {
    if ($row->tid < 999){
      $rows[] = array($row->tid,$row->name,($row->visible)?l(t('edit'), 'admin/settings/biblio/types/edit/'. $row->tid):'',($row->visible)?l(t('hide'), 'admin/settings/biblio/types/hide/'. $row->tid):l(t('show'), 'admin/settings/biblio/types/show/'. $row->tid));
    }else{
      $rows[] = array($row->tid,$row->name,l(t('edit'), 'admin/settings/biblio/types/edit/'. $row->tid),l(t('delete'), 'admin/settings/biblio/types/delete/'. $row->tid));    
    }
  } 
  $header =array(t('Type Id'),t('Type Name'), array('data' => t('Operations'), 'colspan' => '2'));
  $output  = theme('table',$header,$rows);
  $output .= '<p>[ '.l(t('Add New Type'),'admin/settings/biblio/types/add').' ]';
  $output .= ' [ '.l(t('Reset all types to defaults'),'admin/settings/biblio/types/reset').' ]';
  return $output;
  
}
function biblio_types_reset(){

    $form['reset'] = array('#type' => 'value', '#value' => 'reset');

    $output = confirm_form( $form,
           t('Are you sure you want to reset ALL the field definitions to the defaults? '),
           $_GET['destination'] ? $_GET['destination'] : 'admin/settings/biblio/types', 
           t('This action will reset any and all field customizations to the defaults, and cannot be undone!'),
           t('Reset'), t('Cancel')  );
  
    return $output;                

}
function biblio_types_reset_submit($form_id, $edit){
  require_once( drupal_get_path('module', 'biblio') . "/biblio.install");
  biblio_reset_types();
  drupal_goto("admin/settings/biblio/types");

}

function biblio_form_types_edit(){
  if ($arg_list = func_get_args()){// show an existing type  
    $tid = $arg_list[0];
  }  
  // first get all of the field info
  $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
  while ($row = db_fetch_array($result)){
    if($tid){
      if ($row['common']){
        $fields[$row['fid']] = $row;
      }else{
         $other_fields[$row['fid']] = $row;     
      }
    }else{
      $fields[$row['fid']] = $row;
    }
  }
  $form['configured_flds']= array('#tree'=>1);
  $form['cust'] = array('#tree'=>1);
  if ($tid){// show an existing type  

    $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid = %d',$tid);
    $row = db_fetch_array($result);
    $form['type_name'] =array('#type'=>'value','#title'=>'tid','#value'=>$row['name']);
  
   // now get any type specific customizations 
    $result = db_query('SELECT d.*, f.name FROM {biblio_type_details} as d INNER JOIN {biblio_fields} as f on d.fid=f.fid where d.tid=%d  ORDER BY d.weight ASC', $tid);
    while ($row = db_fetch_array($result)){
      $type_fields[$row['fid']] = $row;
      $form['cust'][$row['fid']] =array('#type'=>'value','#value'=>$row['fid']);
      unset($other_fields[$row['fid']]);
    }
    if(count($type_fields)){
    // now merge the customizations with the main field array
    foreach($type_fields as $key=>$value){
        $fields[$key] = (isset($fields[$key])) ? array_merge($fields[$key],$value) : $value;
    } 
    }

    $form['tid'] =array('#type'=>'value','#value'=>$tid);
  } 

  uasort($fields, "_biblio_form_sort"); // resort the fields since the weight may have changed

  $vis_comm = $tid?'visible':'common';
  if (!$tid) $options["$vis_comm"] = '';
  $options['required'] = '';
  $options['autocomplete'] = '';

  foreach($fields as $key=>$fld){
    if ($fld['common']) $def_values[$fld['name']][] = 'common';
    if ($fld['required']) $def_values[$fld['name']][] = 'required';
    if ($fld['autocomplete']) $def_values[$fld['name']][] = 'autocomplete';

    $form['configured_flds'][$key]['name'] = array('#type'=>'markup', '#value'=>$fld['name'],'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['title'] = array('#type'=>'textfield','#default_value' => $fld['title'],'#size'=>15,'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['weight'] = array('#type'=>'textfield','#default_value' => $fld['weight'],'#size'=>2,'#weight'=>$fld['weight']);
    $form['configured_flds'][$key]['hint'] = array('#type'=>'textfield','#default_value' => $fld['hint'],'#size'=>10,'#weight'=>$fld['weight']);
    //if (!$tid){
    //  $form['configured_flds'][$key]['hint']['#type']= 'markup';
    //  $form['configured_flds'][$key]['title']['#type']= 'markup';
    //}
    $form['configured_flds'][$key]['checkboxes'] = array('#type'=>'checkboxes','#options'=>$options,'#default_value' =>$def_values[$fld['name']],'#weight'=>$fld['weight']);      
  }

  if($tid){
    foreach($other_fields as $key=>$fld){
      $form['avail_flds'][$key]['name'] = array('#type'=>'markup', '#value'=>$fld['name'],'#weight'=>$fld['weight']);
      $form['avail_flds'][$key]['title'] = array('#type'=>'markup','#value' => $fld['title'],'#weight'=>$fld['weight']);
      $form['avail_flds'][$key]['size'] = array('#type'=>'markup','#value' => $fld['maxsize'],'#weight'=>$fld['weight']);
    }
  }
  $form['submit'] = array('#type' => 'submit', '#value' => t('Save'));
  
  return $form;
}


function theme_biblio_form_types_edit($form){
  $base =  variable_get('biblio_base', 'biblio');

  $tid = (!empty($form['tid']['#value'])) ? $form['tid']['#value'] : FALSE;

  drupal_set_title($form['type_name']?$form['type_name']['#value']:"Default");

  // build the table with all the fields if no $tid is given, or only the common 
  // and customized fields if $tid is given
  $conf_table = array();
  foreach(element_children($form['configured_flds']) as $fld){
    $conf_row = array();
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['name']));
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['title']),'align' => 'center');
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['hint']),'align' => 'center');
    foreach (element_children($form['configured_flds'][$fld]['checkboxes']) as $oid) {
      if (is_array($form['configured_flds'][$fld]['checkboxes'])) {
            $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['checkboxes'][$oid]), 'align' => 'center', 'title' => t('!oid',array('!oid'=>$oid)));
      }
    }
    $conf_row[] = array('data' => drupal_render($form['configured_flds'][$fld]['weight']),'align' => 'center');
    if ($tid){
      if($form['cust'][$fld]) {
        $conf_row[] = array('data' => l('remove',"$base/type/remove/$tid/$fld"),'align' => 'left');
      }else{
        $conf_row[] = array('data' => "common",'align' => 'left');
      }
    }
   $conf_table[] = $conf_row;
  }
  if ($tid){
    $header =array(t('Field Name'),t('Default Title'),t('Hint'),t('Required'),t('Weight'),t('Action'));
  }else{
    $header =array(t('Field Name'),t('Default Title'),t('Hint'),t('Common'),t('Required'),t('Auto Complete'),t('Weight'));

  }
  
   
  $output .= '<p>';
  drupal_add_js('misc/collapse.js');
  $output .= '<p><fieldset class=" collapsible"><legend>Currently configured fields</legend>';
  $output .= theme('table',$header,$conf_table);
  $output .= '<p><center>'.drupal_render($form['submit']).'</center></p>';
  $output .= '</fieldset>';
 
  if ($tid){
    $avail_table = array();
  
    foreach(element_children($form['avail_flds']) as $fld){
      $avail_row = array();
  
      $avail_row[] = array('data' => '<div>'.drupal_render($form['avail_flds'][$fld]['name']).'</div>');
      $avail_row[] = array('data' => '<div>'.drupal_render($form['avail_flds'][$fld]['size']).'</div>','align' => 'left');
      $avail_row[] = array('data' => '<b>'.drupal_render($form['avail_flds'][$fld]['title']).'</b>','align' => 'left');
      $avail_row[] = array('data' => l('add',"$base/type/add/$tid/$fld"),'align' => 'left');
      $avail_table[] = $avail_row;
    }

    $header2 =array(array('data'=>'Field Name','align'=>'right'),'Size','Default Name','Action');

    $output .= '<p><fieldset class=" collapsible"><legend>Other available fields</legend>';
    $output .= theme('table',$header2,$avail_table);
    $output .= '<p><center>'.drupal_render($form['add']).'</center></p>';
    $output .= '</fieldset>';
  }
  $output .= drupal_render($form);
  return $output;
  
}
function biblio_type_add($tid=0,$fid=0){
   $result = db_query("SELECT fid,title,weight,required,hint FROM {biblio_fields} WHERE fid=%d",$fid);
   if ($fld = db_fetch_object($result)){
     db_query("INSERT INTO {biblio_type_details} (tid, fid, title, weight, required, hint)
                   VALUES (%d,%d,'%s',%d,%d,'%s')",$tid,$fid,$fld->title,$fld->weight,$fld->required,$fld->hint);
   }   
  drupal_goto("admin/settings/biblio/types/edit/$tid");
}
function biblio_type_remove($tid=0,$fid=0){
 
  db_query('DELETE FROM {biblio_type_details} WHERE tid = %d AND fid = %d', $tid,$fid);
  
  drupal_goto("admin/settings/biblio/types/edit/$tid");
}
function biblio_form_types_edit_submit($form_id, $edit) {
  $tid = $edit['tid']?$edit['tid']:false;

  if ($tid){
    $type_query = "UPDATE {biblio_type_details} SET 
                      title = '%s' , weight = %d ,
                      hint = '%s' , required = %d
                      WHERE fid = %d AND tid = %d";
  }else{
    $field_query = "UPDATE {biblio_fields} SET title = '%s', weight = %d, 
                    common = %d, required = %d, autocomplete = %d, hint = '%s' WHERE fid = %d";  
  }

  foreach ($edit['configured_flds'] as $key=>$v){
    $common = ($v['checkboxes']['common'])?TRUE:FALSE;
    $required = ($v['checkboxes']['required'])?TRUE:FALSE;
    $autocomplete = ($v['checkboxes']['autocomplete'])?TRUE:FALSE;
    if(is_numeric($key) ){
      if($tid && $edit['cust'][$key]){ // is type and not a common field update biblio_type_details
        db_query($type_query, $v['title'],$v['weight'],$v['hint'],$required,$key,$tid);      
      }elseif(!$tid){ // is a common field, update the biblio_field table
        db_query($field_query, $v['title'],$v['weight'],$common,$required,$autocomplete,$v['hint'],$key);
      }
    }
 }    

  drupal_set_message(t("The changes have been saved."));

  // Clear the cached pages and menus:
  menu_rebuild();
// drupal_goto('admin/settings/biblio/types');  

}
function _biblio_form_sort($a, $b) {
  $a_weight = (is_array($a) && isset($a['weight'])) ? $a['weight'] : 0;
  $b_weight = (is_array($b) && isset($b['weight'])) ? $b['weight'] : 0;
  if ($a_weight == $b_weight) {
    return 0;
  }
  return ($a_weight < $b_weight) ? -1 : 1;
}

function biblio_filter_clear() {
  $_SESSION['biblio_filter'] = array();
  $base =  variable_get('biblio_base', 'biblio');
  drupal_goto($base);
} 

function _get_biblio_filters(){
  $result = db_query('SELECT b.biblio_year, b.biblio_authors, t.name , t.tid FROM {biblio} as b  left join {biblio_types} as t on b.biblio_type = t.tid ORDER BY b.biblio_year DESC');
  while ($option = db_fetch_object($result)) {
    if ($option->biblio_year == 0) { $option->biblio_year = t("In Press"); }
    $pub_years["$option->biblio_year"] = t("!year",array('!year'=>$option->biblio_year));
    $pub_type["$option->tid"] = t("!name",array('!name'=>$option->name));
    $author_array = explode(";", $option->biblio_authors);
    foreach($author_array as $auth) {
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = trim($parts[0]);
      } else {
        $parts = split(" ", $auth);
        $lastname = trim(end($parts));
      } 
      if ($lastname) $pub_authors["$lastname"] = $lastname;
    } 
  } 
  $pub_years = array_unique($pub_years);
  $pub_type = array_unique($pub_type);
  ksort($pub_authors);
  $filters = array('author' => array('title' => t('Author'),
      'options' => $pub_authors),
    'type' => array('title' => t('Type'),
      'options' => $pub_type),
    'year' => array('title' => t('Year'),
      'options' => $pub_years)); 
  
  return $filters;
}

function biblio_form_filter() {
  $session = &$_SESSION['biblio_filter'];
  $session = is_array($session) ? $session : array();
  $filters = _get_biblio_filters();

   $i = 0;
  $form['filters'] = array('#type' => 'fieldset',
    '#title' => t('Show only items where'),
    '#theme' => 'biblio_filters',
  );
  foreach ($session as $filter) {
    list($type, $value) = $filter;
    if ($type == 'category') {
      // Load term name from DB rather than search and parse options array.
      $value = module_invoke('taxonomy', 'get_term', $value);
      $value = $value->name;
    }else if ($type == 'keyword'){
      $filters[$type]['title'] = 'Keyword';
    }else {
      $value = $filters[$type]['options'][$value];
    }
    $string = ($i++ ? '<em>and</em> where <strong>%a</strong> is <strong>%b</strong>' : '<strong>%a</strong> is <strong>%b</strong>');
    $form['filters']['current'][] = array('#value' => t($string, array('%a' => $filters[$type]['title'] , '%b' => $value)));
  }

  foreach ($filters as $key => $filter) {
    $names[$key] = $filter['title'];
    $form['filters']['status'][$key] = array('#type' => 'select', '#options' => $filter['options']);
  }
  $form['filters']['status']['keyword']=array('#type' => 'textfield','#size' => 25, '#maxlength' => 255);
  $names['keyword'] = "Keyword";

  $form['filters']['filter'] = array('#type' => 'radios', '#options' => $names, '#default_value' => 'status');
  $form['filters']['buttons']['submit'] = array('#type' => 'submit', '#value' => (count($session) ? t('Refine') : t('Filter')));
  if (count($session)) {
    $form['filters']['buttons']['undo'] = array('#type' => 'submit', '#value' => t('Undo'));
    $form['filters']['buttons']['reset'] = array('#type' => 'submit', '#value' => t('Reset'));
  }

  return  $form;
}
function theme_biblio_filters(&$form) {

  if (sizeof($form['current'])) {
  $output .= '<ul>';
    foreach (element_children($form['current']) as $key) {
      $output .= '<li>' . drupal_render($form['current'][$key]) . '</li>';
    }
  }

  $output .= '<dl class="multiselect">' . (sizeof($form['current']) ? '<dt><em>'. t('and') .'</em> '. t('where') .'</dt>' : '') . '<dd class="a">';
  foreach (element_children($form['filter']) as $key) {
    $output .= drupal_render($form['filter'][$key]);
  }
  $output .= '</dd>';

  $output .= '<dt>'. t('is') .'</dt>' . '<dd class="b">';

  foreach (element_children($form['status']) as $key) {
    $output .= drupal_render($form['status'][$key]);
  }
  $output .= '</dd>';

  $output .= '</dl>';
  $output .= '<div class="container-inline" id="node-buttons">'. drupal_render($form['buttons']) .'</div>';
  $output .= '</li></ul><br class="clear" />';

  return $output;
}

function biblio_form_filter_submit($form_id,$form_values) {
  //global $form_values;
  $op = $form_values['op'];
  $filters = _get_biblio_filters();
  switch ($op) {
    case t('Filter'):
    case t('Refine'):
      if (isset($form_values['filter'])) {
        $filter = $form_values['filter'];

        // Flatten the options array to accommodate hierarchical/nested options.
        if (isset($filters[$filter]['options'])){
          $flat_options = form_options_flatten($filters[$filter]['options']);
        }
        if (isset($flat_options[$form_values[$filter]]) || $filter == 'keyword') {
          $_SESSION['biblio_filter'][] = array($filter, $form_values[$filter]);
          $base =  variable_get('biblio_base', 'biblio');
          drupal_goto($base);

        }
      }
      break;
    case t('Undo'):
      array_pop($_SESSION['biblio_filter']);
      break;
    case t('Reset'):
      $_SESSION['biblio_filter'] = array();
      break;
  }
} 
function theme_biblio_form_filter(&$form) {

  $output .= '<div id="biblio-admin-filter">';
  $output .= drupal_render($form['filters']);
  $output .= '</div>';
  $output .= drupal_render($form);
  return $output;
}

/*function theme_biblio_node_form($form){
echo "in node form";die;
}
*/
function biblio_submit(&$node){
  if (variable_get('biblio_keyword_freetagging',0) && variable_get('biblio_freetagging_vocab',0)){
    $vid = variable_get('biblio_freetagging_vocab',0);
    $node->taxonomy['tags'][$vid] = $node->biblio_keywords;
  }
}
//function biblio_pre_render($form_id, &$form, $next_page = TRUE) {
function theme_biblio_node_form($form) {
  global $form_values;
 //print_r($form);
    if ( isset($form['biblio_type']['#value']) && $form['biblio_type']['#value'] >0 ){

    $form['title']['#type'] = 'textfield';

    $form['body']['#type'] = 'textarea';

    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)){
        $fields[$row['fid']] = $row;
        if($row['common']) $form[$row['name']]['#type'] = $row['type'];
    }
 
    $result = db_query('SELECT b.*, c.name, c.type FROM {biblio_type_details} as b INNER JOIN {biblio_fields} as c ON b.fid = c.fid where tid= %d ORDER BY b.weight ASC',$form['biblio_type']['#value']);
    while ($row = db_fetch_array($result)){
      $type_fields[$row['fid']] = $row;
      $form[$row['name']]['#type'] = $row['type'];
    }
    
    if(count($type_fields)){
    // now merge the customizations with the main field array
      foreach($type_fields as $key=>$value){
        $fields[$key] = array_merge($fields[$key],$value);
      } 
    }

    foreach ($fields as $key=>$fld){
  
      $form[$fld['name']] = array_merge($form[$fld['name']],array(
                                          '#default_value' => $node->$fld['name'],
                                          '#title' => t('!title',array('!title'=>$fld['title'])),
                                          '#required' => $fld['required'],
                                          '#size' => $fld['size'],
                                          '#maxlength' => $fld['maxsize'],
                                          '#weight' => $fld['weight']/10,
                                          '#description' => $fld['hint'])
                                        ); // end array_merge

    } //end foreach

  }//endif ($form_id == 'biblio_node_form...  
    $output .= drupal_render($form);
  return $output;

}


/**
* Implementation of hook_form().
* 
* Create the form for collecting the information
* specific to this node type. This hook requires us to return some HTML
* that will be later placed inside the form.
*/
function biblio_form(&$node, &$param) {
  global $form_values;
  $output = '';
  $param['options'] = array("enctype" => "multipart/form-data"); 

  //$form['#pre_render'] = array('biblio_pre_render');

  $result = db_query('SELECT t.* FROM {biblio_types} as t WHERE tid > -2 AND visible = 1');
  while ($option = db_fetch_object($result)) {
    $options["$option->tid"] = t('!name',array('!name'=>$option->name));
  } 

  $form['biblio_type'] = array(
    '#type' => 'select', 
    '#title' => t('Publication Type'),
    '#default_value' => $node->biblio_type,
    '#options' => $options,
    '#description' => null,
    '#weight' => -5,
    '#attributes' => array('onchange'=>'document.getElementById(\'node-form\').submit()'),
    '#multiple' => false, '#required' => true);

  $form['title']= array( // this will be set to textfield type in pre_render once the pub type is set.
    '#type' => 'value',
    '#title' => t('Title'),
    '#required' => TRUE,
    '#default_value' => $node->title,
    '#size' => 60,
    '#maxlength' => 255,
    '#weight' => -4
  );

    // Build the field array used to make the form
    $result = db_query('SELECT * FROM {biblio_fields} as b  ORDER BY b.weight ASC');
    while ($row = db_fetch_array($result)){
     // if($row['common']){
        $fields[$row['fid']] = $row;
     // }
    }
    
    // Now set all the fields to "value" type so the will not be visible, and 
    // then in biblio_pre_render the correct type will be set.
    foreach ($fields as $key=>$fld){
          $form[$fld['name']] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'value',
          '#title' => t('!title',array('!title'=>$fld['title'])),
          '#size' => $fld['size'],
          '#required' => $fld['required'],
          '#maxlength' => $fld['maxsize'],
          '#weight' => $fld['weight']/10,
          '#autocomplete_path' => ($fld['autocomplete']) ? 'biblio/autocomplete/'.$fld['name'] : '',
          '#description' => $fld['hint']
        );

    }    
 /*   $form['authors1'] = array('#type' => 'fieldset', 
                              '#title' => t('First Authors'),
                              '#collapsible' => TRUE, 
                              '#collapsed' => TRUE, 
                              '#weight' => 0);
    $form['authors1']['author1_lastname'] = array(
          '#default_value' => $node->$fld['name'],
          '#type' => 'textfield',
          '#title' => t('lastname'),
          '#size' => 20,
          '#required' => 1,
          '#maxlength' => 75,
          '#weight' => 1,
          '#description' => ''
        );

    $form['authors2'] = array('#type' => 'value', 
                              '#title' => t('More Authors...'), 
                              '#collapsible' => TRUE, 
                              '#collapsed' => TRUE, 
                              '#weight' => 0);
  */  
    $form['body'] = array('#type' => 'value', 
                               '#title' => t('Full Text'), 
                               '#default_value' => $node->body, 
                               '#rows' => 10, '#required' => FALSE,
                               '#description' => t('You may enter a full text or HTML version of the publication here.'),
                               '#weight' => 19);
  $form['format'] = filter_form($node->format,20);

 return $form;
} 

/**
* Implementation of hook_validate().
* 
* 
* Errors should be signaled with form_set_error().
*/
function biblio_validate(&$node) {

  if ($node->biblio_type == 0) {
    form_set_error('biblio_type', t('You must select the type of publication'));
    return;
  } 
  if (!$node->biblio_authors) {
    form_set_error('biblio_authors', t('You must supply at least one author name'));
  } 
  /*  if (!strstr("$node->biblio_authors", ";")) {
    form_set_error('biblio_authors', t('You must separate the author names with semicolons'));
  } 
*/
  if (!isset($node->biblio_year)) {
    form_set_error('biblio_year', t('You must supply the year of publication'));
  } else {
    $today = getdate();
    if (($node->biblio_year == t("In Press")) or ($node->biblio_year == 0)) {
        $node->biblio_year = 0;
    }
    elseif ($node->biblio_year < 1 || $node->biblio_year > $today['year'])      form_set_error('biblio_year', t('Year of Publication must be a number between 1 and ') . $today['year']);
  } 
  /*  if (!$node->biblio_secondary_title) {
    form_set_error('biblio_secondary_title', t('You must supply the Journal Title, Conference Name or Book Title'));
  } 
*/

} 
function biblio_insert_authors($nid, $authors=array() ){

}
/**
* Implementation of hook_insert().
* 
* As a new node is being inserted into the database, we need to do our own
* database inserts.
*/
function biblio_insert($node) {
  // Prepare the query:
  $fields = biblio_get_db_fields();
  foreach ($node as $key => $value) {
    if (in_array((string) $key, $fields)) {
      $k[] = db_escape_string($key);
      $v[] = $value;
      $s[] = "'%s'";
    } 
  } 
  // Insert the node into the database:
  db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
} 

/**
* Implementation of hook_update().
* 
* As an existing node is being updated in the database, we need to do our own
* database updates.
*/
function biblio_update($node) {
  $fields = biblio_get_db_fields();
  foreach ($node as $key => $value) {
    if (in_array($key, $fields) && $key !="0") { //$key != "0" to fix a bug related to book module
      $k[] = db_escape_string($key);
      $q[] = end($k) . " = '%s'";
      $v[] = $value;
      $s[] = "'%s'";
    } 
  } 
  // Update the node in the database:
  if ($node->revision){
    db_query("INSERT INTO {biblio} (" . implode(", ", $k) . ") VALUES(" . implode(", ", $s) . ")", $v);
  }else{
    db_query("UPDATE {biblio} SET " . implode(', ', $q) . " WHERE vid = '$node->vid'", $v);
  }  
} 

/**
* Implementation of hook_delete().
* 
* When a node is deleted, we need to clean up related tables.
*/
function biblio_delete($node) {
  db_query('DELETE FROM {biblio} WHERE nid = %d', $node->nid);
  db_query('DELETE FROM {biblio_has_author} WHERE nid = %d', $node->nid);
} 

/**
* Implementation of hook_load().
* 
* This hook is called
* every time a node is loaded, and allows us to do some loading of our own.
* 
*/
function biblio_load($node) {
  $additions = db_fetch_object(db_query('SELECT * FROM {biblio} WHERE vid = %d', $node->vid));
  return $additions;
} 
function biblio_citekey_view(){
  $citekey = arg(2);
  $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
  if ($nid->nid > 0){
    $node = node_load($nid->nid);
    return node_page_view($node);
  } else {
    return t("Sorry, citekey: ").$citekey.t(" not found");
  }

}
/**
* Implementation of hook_view().
* 
* This is a typical implementation that simply runs the node text through
* the output filters.
*/
function biblio_view(&$node, $teaser = false, $page = false) {
//print_r($node);
  drupal_add_css(drupal_get_path('module', 'biblio').'/biblio.css');

  $node = node_prepare($node, $teaser);
  $layout = variable_get('biblio_node_layout', 'orig');
  switch ($layout){
  case 'orig':
  default:
    $node->content['biblio'] = array('#value' => theme('biblio_long', $node), '#weight' => -10 );
    $node->content['body']['#value'] =   (!empty($node->body))?'<h3>'.t('Full Text').':</h3>'.$node->body:"";
    break;
  case 'ft':
    $node->content['biblio'] = (!empty($node->body))?array('#value' => '<div class="biblio-head">'.theme('biblio_short', $node).'</div>',
                                               '#weight' => -10 )
                                        :array('#value' => theme('biblio_long', $node),
                            '#weight' => -10 );

    break;                                      
  }
  $base =  variable_get('biblio_base', 'biblio');
  drupal_set_breadcrumb(array(l(t('Home'), NULL), l(t($base), $base)));

return $node;
//  $biblio_info = theme('biblio_long', $node);
//  $node->body = $biblio_info . ($node->body?"<br /><br /><B>Full Text:</b><br />".$node->body:"");
//  $node->teaser .= $biblio_info; 
  // $node = node_prepare($node, $teaser);
} 

/**
* Implementation of hook_block().
* 
* Generates a block containing the latest poll.
*/
function biblio_block($op = 'list', $delta = 0) {
  if (user_access('access content')) {
    if ($op == 'list') {
      $blocks[0]['info'] = t('Most recent publications');
      return $blocks;
    } else if ($op == 'view') {
      // Retrieve the latest pubs
      $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, n.status FROM {node} AS n WHERE n.type = 'biblio' AND n.status=1 ORDER BY n.created DESC"), 0, 4);
      if (db_num_rows($result)) {
        $base =  variable_get('biblio_base', 'biblio');
        $block['subject'] = t('New Publications');
        $block['content'] .= '<div class="item-list"><ul>';
        while ($pub = db_fetch_object($result)) {
          $block['content'] .= '<li >' . l("$pub->title", "node/$pub->nid") . '</li>';
        }
        if (variable_get('biblio_rss', 0)){ 
          $block['content'] .=  theme('feed_icon', url("$base/rss.xml"));
        }
        $block['content'] .= '</ul></div>';
      } 
      return $block;
    } 
  } 
} 

function biblio_feed(){
      
  $result = db_query_range(db_rewrite_sql("SELECT * FROM {node} AS n left join {biblio} b  on n.vid=b.vid WHERE n.type = 'biblio' AND n.status=1 ORDER BY n.created DESC"), 0, 6);
  $channel['title'] = variable_get('site_name', 'Drupal') .' - '. t("New Publications");
  node_feed($result, $channel);

}

function theme_biblio_long($pub) {

  if (variable_get('biblio_normalize', 0)) {
    $authors = check_plain(_biblio_parse_authors($pub->biblio_authors));
  } else {
    $authors = check_plain($pub->biblio_authors);
  } 

  $output .= '<div class="biblio_authors"><H3>'.t("Authors").':</H3> ' . _biblio_author_links($authors) . "</div>\n";
  $output .= '<div class="biblio_source"><H3>'.t("Source").': </H3> ';
  $source = null;
  if ($pub->biblio_secondary_title) $source .= check_plain($pub->biblio_secondary_title);
  if ($pub->biblio_publisher) {
    $source .= $source?", ":"";
    $source .= check_plain($pub->biblio_publisher);
  } 
  if ($pub->biblio_volume) {
    $source .= $source?", ":"";
    $source .= t('Volume ') . check_plain($pub->biblio_volume);
  } 
  if ($pub->biblio_issue) {
    $source .= $source?", ":"";
    $source .= t('Issue ') . check_plain($pub->biblio_issue);
  } 
  if ($pub->biblio_number) {
    $source .= $source?", ":"";
    $source .= t('Number ') . check_plain($pub->biblio_number);
  } 

  if ($pub->biblio_place_published) {
    $source .= $source?", ":"";
    $source .= check_plain($pub->biblio_place_published);
  } 
  if ($pub->biblio_pages) {
    $source .= $source?", ":"";
    $source .= 'p.' . check_plain($pub->biblio_pages);
  } 
  if (isset($pub->biblio_year)) {
    if ($pub->biblio_year == 0) { $pub->biblio_year = t("In Press"); }
    $source .= ' (' . check_plain($pub->biblio_year) . ')';
  } 
  $output .= "$source</div>\n";

  if ($pub->biblio_isbn) $output .= '<h3>'.t("ISBN").':</h3> ' . check_plain($pub->biblio_isbn) . "\n";
  if ($pub->biblio_call_number) $output .= '<h3>'.t("Call Number").':</h3> ' . check_plain($pub->biblio_call_number) . "\n";
  if ($pub->biblio_accession_number) $output .= '<h3>'.t("Accession Number").':</h3> ' . check_plain($pub->biblio_accession_number) . "\n";
  if ($pub->biblio_other_number) $output .= '<h3>'.t("Other Number").':</h3> ' . check_plain($pub->biblio_other_number) . "\n";
  if ($pub->biblio_url) $output .= '<h3>'.t("URL").':</h3>'.l("$pub->biblio_url",$pub->biblio_url) . "\n";
  if ($pub->biblio_keywords) $output .= '<h3>'.t("Keywords").':</h3> ' . _biblio_keyword_links($pub->biblio_keywords) . "\n";
  if ($pub->biblio_abst_e) $output .= '<H3>'.t("Abstract").':</h3> ' . check_markup($pub->biblio_abst_e,FILTER_HTML_ESCAPE,FALSE) . "\n";
  if ($pub->biblio_abst_f) $output .= '<p>' . check_markup($pub->biblio_abst_f,FILTER_HTML_ESCAPE,FALSE) . "\n";
  if ($pub->biblio_notes) $output .= '<h3>'.t("Notes").': </h3>' . check_markup($pub->biblio_notes,FILTER_HTML_ESCAPE,FALSE) . "\n";
  if ( biblio_access('export',$pub)) {
    $base =  variable_get('biblio_base', 'biblio');
    $output .= '<br /><br />Export: ['.l(t("Tagged"),"$base/export/tagged/$pub->nid").']';
    $output .= '['.l(t("XML"),"$base/export/xml/$pub->nid").']';
    $output .= '['.l(t("BibTex"),"$base/export/bib/$pub->nid").']<br /><br />';
  } 

  return $output;
} 

function theme_biblio_short($pub,$style=null) {
  $style_name = $style ? $sytle : variable_get('biblio_style', 'classic');
  require_once( drupal_get_path('module', 'biblio') . "/biblio_style_$style_name.inc");
  
  $style_function = "biblio_style_$style_name";
  return($style_function($pub));

}
function theme_biblio_list($pub,$style=null) {
//  var $output;
  $output = theme_biblio_short($pub);
  if ($pub->biblio_abst_e) $output .= l(" Abstract", "node/$pub->nid") . "\n";
  if ( biblio_access('export',$pub)) {
    $base =  variable_get('biblio_base', 'biblio');
    $output .= '<br /><em>Export: '.l("Tagged","$base/export/tagged/$pub->nid") . '&nbsp;';
    $output .= l("XML","$base/export/xml/$pub->nid") . '&nbsp;';
    $output .= l("BibTex","$base/export/bib/$pub->nid") . '</em>';
  } 
  return $output;
} 

function biblio_show_results($result, $attrib = array("sort" => 'year', 'order' => 'DESC'), $args = null,$inline=false) {
  global $pager_total_items;
  $base =  variable_get('biblio_base', 'biblio');
  drupal_add_css(drupal_get_path('module', 'biblio').'/biblio.css');
  if(variable_get('biblio_rss', 0)){  
    drupal_set_html_head('<link rel="alternate" type="application/rss+xml" title="'.variable_get('site_name', 'Drupal').' RSS" href="'.url("$base/rss.xml").'" />');
  }  
  $pub_types = db_query('SELECT t.* FROM {biblio_types} as t WHERE t.tid>0');
  while ($option = db_fetch_object($pub_types)) {
    $pub_type["$option->tid"] = t('!name',array('!name'=>$option->name));
  } 
  if(!$inline){
    // Add some links to the top of the page to change the sorting/ordering...
    $order = ($attrib['order'] == "desc" || $attrib['order'] == "DESC")?"asc":"desc";
    if ( biblio_access('export',$pub)) {
      $content .= '<div class="biblio_export">'.t('Export').' (' . $pager_total_items[0] . ') '.t('results').':['.l("Tagged","$base/export/tagged"). ']['.l("XML","$base/export/xml"). ']['.l("BibTex","$base/export/bib").']</div>';
    }else{
      $content .= '<div class="biblio_export">'.t('Found ').$pager_total_items[0] . t(' results') .'</div><br>';    
    }
    if(user_access('show sort links')){
      $sort_attr = array("title"=>t("Click a second time to reverse the sort order"));
      $content .= '<div class="biblio_sort">'.t('Sort by').':';
      $content .= "[".l(t("Year"),$_GET['q'],$sort_attr,"sort=year&order=$order");
      $content .= "][".l(t("Title"),$_GET['q'],$sort_attr,"sort=title&order=$order");
      $content .= "][".l(t("Type"),$_GET['q'],$sort_attr,"sort=type&order=$order");
      $content .= "][".l(t("Author"),$_GET['q'],$sort_attr,"sort=author&order=$order");
      $content .= "]</div> ";
    }
  }
  $session = &$_SESSION['biblio_filter'];
  if (count($args)) {
    $content .= '<b>'.t('Filters').': </b>';
    while ($args) {
      $type = $args[0];
      array_shift($args);
      $value = db_escape_string($args[0]);
      if ($type == 'type') $value = $pub_type["$value"];
      array_shift($args);
      $params = array('%a' =>  $type , '%b' =>  $value );
      $content .= ($i++ ? t('<em> and</em> <strong>%a</strong> is <strong>%b</strong>', $params) : t('<strong>%a</strong> is <strong>%b</strong>', $params)) . '</li>';
    } 
    $content .= '&nbsp;&nbsp;'.l('['.t('Clear All Filters').']',"$base/filter/clear");
  } while ($pub = db_fetch_object($result)) {
    switch ($attrib['sort']) {
      case 'title':
        if ( drupal_substr($pub->title, 0, 1)  != $_char) {
          $_char = drupal_substr($pub->title, 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        } 
        break;
      case 'author':
        if ( drupal_substr($pub->author, 0, 1) != $_char) {
          $_char = drupal_substr($pub->author, 0, 1) ;
          $content .= '<div class="biblio-year">' . $_char . "</div>\n";
        } 
        break;
      case 'type':
        if ($pub->biblio_type != $_type) {
          $_type = $pub->biblio_type;
          $name = db_result(db_query("SELECT name FROM {biblio_types} as t where t.tid=%d", $pub->biblio_type)) ;
          $content .= '<div class="biblio-year">' . $name . "</div>\n";
        } 
        break;
      case 'year':
      default:
        if ($pub->biblio_year != $_year) {
          $_year = $pub->biblio_year;
          $content .= '<div class="biblio-year">'
                   .  ((isset($_year) and ($_year == 0)) ? t("In Press")
                                                         : $_year)
                   .  "</div>\n";        } 
    } //end switch
    $content .= '<div class="biblio-entry">' . "\n";
    $content .= theme('biblio_list', $pub);
    $content .= "</div>\n";
  } //end while
  $content .= theme('pager', 0, variable_get('biblio_rowsperpage', 25));
  if (!db_num_rows($result)) {
    $content .= "<H3>".t("No items found")."</H3>";
    if (strstr($content, "Filters:")) {
      $content .= l(t('Modify'),"$base/filter");
      $content .= ' or '.l(t('remove'),"$base/filter/clear").' your filters and try again.';
    }
  } 
  if (!$inline) {
    print theme('page', $content);
  }else{ 
    print $content;
  }

} 

function biblio_db_search() {
global $user;
$inline = false;
$join = array();
  $join[] = "left join {biblio} b  on n.vid=b.vid";
   if (variable_get('biblio_view_only_own', 0) ){
      $limit .= " AND n.uid=$user->uid ";
   }

  $pager_attrib = array("sort" => variable_get('biblio_sort', 'year'), 'order' => variable_get('biblio_order', 'DESC'));
  $limits = null;

  if (isset($_GET['order'])){
    $pager_attrib['order'] = ($_GET['order'] == 'desc') ? 'desc' : 'asc';
  }
  if (isset($_GET['sort'])) {
    $pager_attrib['sort'] = check_plain($_GET['sort']);
  } 

  switch ($pager_attrib['sort']) {
    case 'type':
      $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
      break;
    case 'title':
      $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
      break;
    case 'author':
      $join[] = "inner join {biblio_has_author} as ha on a.aid = ha.aid"; 
      $join[] = "inner join  {biblio_author_index} as a on b.nid= ha.nid";
      $sortby = " ORDER BY a.author %s ";
      $where[] = "ha.rank = 1 ";
      //$sortby = "ORDER BY SUBSTRING(LTRIM(b.biblio_authors),1,1) %s, b.biblio_year DESC ";
      break;
    case 'year':
    default:
      $sortby = "ORDER BY b.biblio_year %s, b.biblio_date DESC, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
  } //end switch
  if (!isset($_SESSION['biblio_filter']) || !is_array($_SESSION['biblio_filter'])) {
    $_SESSION['biblio_filter'] = array();
  } 

  $session = &$_SESSION['biblio_filter'];
  
  $numargs = func_num_args();
  $arg_list = func_get_args();
  foreach ($session as $filter) {
    $arg_list = array_merge($arg_list, $filter);
  } 
  if (count($arg_list) >= 2) {
    $args = array();
    while ($arg_list) {
      $type = $arg_list[0];
      array_shift($arg_list);
      switch ($type) {
        case 'inline':
          $inline = true;
          break;
        case 'author':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $limit .= " AND MATCH(b.biblio_authors) AGAINST('%s')";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          break;
        case 'publisher':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $limit .= " AND MATCH(b.biblio_publisher) AGAINST('%s')";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          break;
        case 'year':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $where[] = "b.biblio_year=%d ";
          //$limit .= " AND b.biblio_year=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          break;
        case 'keyword':
          $term = explode("?",$arg_list[0]);
          array_shift($arg_list);
          $limit .= " AND MATCH(b.biblio_keywords) AGAINST('%s')";
          $terms[] = db_escape_string($term[0]);
          array_push($args, $type, $term[0]);
          break;
        case 'type':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $limit .= " AND b.biblio_type=%d ";
          $terms[] = (int)$term;
          array_push($args, $type, (int)$term);
          break;
        case 'order':
          $term = (db_escape_string($arg_list[0]) == 'desc')?'desc':'asc';
          array_shift($arg_list);
          $pager_attrib['order'] = $term;
          array_push($args, $type, $term);
          break;
        case 'sort':
          $term = db_escape_string($arg_list[0]);
          array_shift($arg_list);
          $pager_attrib['sort'] = $term;
          array_push($args, $type, $term);
          switch ($term) {
            case 'type':
              $sortby = "ORDER BY b.biblio_type %s, b.biblio_year DESC, SUBSTRING(n.title,1,1) ASC ";
              break;
            case 'title':
              $sortby = "ORDER BY SUBSTRING(n.title,1,1) %s, b.biblio_year DESC ";
              break;
            case 'year':
            default:
              $sortby = "ORDER BY b.biblio_year %s, SUBSTRING(n.title,1,1) ASC, b.biblio_type ASC ";
          } //end switch
          break;
      } 
    } 
  } 
  $where[] = "n.type='biblio' ";
  if ($user->uid > 1) {
    $where[] = 'n.status = 1 ';
  }//show only published entries to everyone except admin
  
  $joins = implode(' ', $join);

  $where_clause = count($where) > 1 ? '('. implode(') AND (', $where) .')': $where[0];

  $query = "SELECT * FROM {node} n $joins  WHERE $where_clause $published $limit $sortby ";
//echo $query; die;
  $_SESSION['last_biblio_query'] = $query;
  $terms[] = $pager_attrib['order'];
  $_SESSION['last_biblio_query_terms'] = $terms;

  $result = pager_query(db_rewrite_sql($query), variable_get('biblio_rowsperpage', 25),0,null,$terms);

  biblio_show_results($result, $pager_attrib, $args,$inline);
} 
function _biblio_export($format="tagged", $nid = null, $version = 7) {
$params=array();
  if ($nid === null && isset($_SESSION['last_biblio_query']) && !empty($_SESSION['last_biblio_query']) ) {
    $query = $_SESSION['last_biblio_query'];
    $params = $_SESSION['last_biblio_query_terms'];    
  } elseif (!empty($nid)) {
    $query = "SELECT * FROM {node} n left join {biblio} b  on n.vid=b.vid 
                WHERE n.nid=%d ";
    $params[] = $nid;
  }else{
    return;
  } 

  $result = db_query(db_rewrite_sql($query),$params);

  if (db_num_rows($result)) {
     switch($format){
     case "tagged":
       _endnote_tagged_export($result);
       break;
     case "xml":
       _endnote_XML_export($result, $version );
       break;
     case "bib":
       _bibtex_export($result);
       break;
     }
  }
}
function _bibtex_export($result){

$bibtex = '';
    while ($pub = db_fetch_object($result)) {
    $type = "article";
    $journal = $series = $booktitle = $school = $organization = null;
    switch ($pub->biblio_type){
      case 102:
        $type = "article";
        $journal = $pub->biblio_secondary_title;
       break; 
      case 100:
        $type = "book";
        $series = $pub->biblio_secondary_title;
         break; 
      case 101:
        $type = "inbook";
        $booktitle = $pub->biblio_secondary_title;
         break; 
      case 103:
        $type = "conference";
         break; 
      case 100:
        $type = "incollection";
         break; 
      case 103:
        $type = "inproceedings";
         break; 
      case 129:
        $type = "misc";
         break; 
      case 108:
        $type = "phdthesis";
        $school = $pub->biblio_publisher;
        $pub->biblio_publisher = null;
         break; 
      case 104:
        $type = "proceedings";
         break; 
      case 109:
        $type = "techreport";
        $organization = $pub->biblio_publisher;
        $pub->biblio_publisher = null;
         break; 
      case 124:
        $type = "unpublished";
         break; 
    }
    
    $bibtex .= '@'.$type.' { ';
    $bibtex .= ($pub->biblio_citekey)? $pub->biblio_citekey.",\n":",\n";
    if($pub->title) $bibtex .= "\ttitle = {".$pub->title."},\n";
    if($journal) $bibtex .= "\tjournal = {".$journal."},\n";
    if($booktitle) $bibtex .= "\tbooktitle = {".$booktitle."},\n";
    if($series) $bibtex .= "\tseries = {".$series."},\n";
    if($pub->biblio_secondary_authors) $bibtex .= "\teditor = {".$pub->biblio_secondary_authors."},\n";
    if($pub->biblio_volume) $bibtex .= "\tvolume = {".$pub->biblio_volume."},\n";
    if($pub->biblio_number) $bibtex .= "\tnumber = {".$pub->biblio_number."},\n";
    if($pub->biblio_year) $bibtex .= "\tyear = {".$pub->biblio_year."},\n";
    if($pub->biblio_notes) $bibtex .= "\tnote = {".$pub->biblio_notes."},\n";
    if($pub->biblio_date) $bibtex .= "\tmonth = {".$pub->biblio_date."},\n";
    if($pub->biblio_pages) $bibtex .= "\tpages = {".$pub->biblio_pages."},\n";
    if($pub->biblio_publisher) $bibtex .= "\tpublisher = {".$pub->biblio_publisher."},\n";
    if($school) $bibtex .= "\tschool = {".$school."},\n";
    if($organization) $bibtex .= "\torganization = {".$organization."},\n";
    if($institution) $bibtex .= "\tinstitution = {".$institution."},\n";
    if($pub->biblio_type_of_work) $bibtex .= "\ttype = {".$pub->biblio_type_of_work."},\n";
    if($pub->biblio_edition) $bibtex .= "\tedition = {".$pub->biblio_edition."},\n";
    if($pub->biblio_section) $bibtex .= "\tchapter = {".$pub->biblio_section."},\n";
    if($pub->biblio_place_published) $bibtex .= "\taddress = {".$pub->biblio_place_published."},\n";
    if($pub->biblio_abst_e) $bibtex .= "\tabstract = {".$pub->biblio_abst_e."},\n";
    if($pub->biblio_keywords) $bibtex .= "\tkeywords = {".$pub->biblio_keywords."},\n";
    if($pub->biblio_isbn) $bibtex .= "\tISBN = {".$pub->biblio_isbn."},\n";
    if($pub->biblio_url) $bibtex .= "\tURL = {".$pub->biblio_url."},\n";
    $author =  str_replace("; ", " and ", $pub->biblio_authors);
    $bibtex .= "\tauthor = {".$author."}\n";
    
    $bibtex.="}\n\n";

  }

  header('Content-type: 	application/text');
  header('Content-Disposition:  filename="bibtex.bib"');
  print utf8_decode($bibtex);


}
function _endnote_XML_export($result, $version = 7) {

   if ($version == 8){
      require_once(drupal_get_path('module', 'biblio') . '/endnote8_export.inc');
     $xml = _endnote8_XML_export($result);
    }elseif ($version == 7){
      require_once(drupal_get_path('module', 'biblio') . '/endnote7_export.inc');
     $xml = _endnote7_XML_export($result);
    }
    header('Content-type: application/xml; charset=utf-8');
    header('Content-Disposition: attachment; filename="endnote'.$version.'.xml"');
    echo $xml;
}

function _endnote_tagged_export($result) {

    $doc = "";
    while ($pub = db_fetch_object($result)) {
      switch ($pub->biblio_type) {
        case 1:
        case 102: $doc .= "%0 Journal Article\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%J " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // journal
        case 2:  
        case 103: $doc .= "%0 Conference Paper\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break;
        case 3: // are all
        case 4: $doc .= "%0 Conference Proceedings\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // conference proceedings 
        case 5: 
        case 109:
          $doc .= "%0 Report\r\n";
          break; // report
        case 6: 
        case 101:
          $doc .= "%0 Book Section\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // book section
        case 7: 
        case 108:
          $doc .= "%0 Thesis\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // thesis
        case 8: 
        case 119:
          $doc .= "%0 Patent\r\n";
          if ($pub->biblio_secondary_title) $doc .= "%B " . trim($pub->biblio_secondary_title) . "\r\n";
          break; // patent
        case 9:
        default:
          $doc .= "%0 Generic\r\n";
          break; // generic
      } 
      $doc .= "%D " . trim($pub->biblio_year) . "\r\n";
      $doc .= "%T " . trim($pub->title) . "\r\n";
      if (variable_get('biblio_normalize', 0)) {
        $pub_authors = _biblio_parse_authors($pub->biblio_authors);
      } else {
        $pub_authors = $pub->biblio_authors;
      } 
      $author_array = explode(";", $pub_authors);
      foreach($author_array as $auth) {
        $doc .= "%A " . trim($auth) . "\r\n";
      } 

      if ($pub->biblio_place_published) $doc .= "%C " . trim($pub->biblio_place_published) . "\r\n";
      if ($pub->biblio_secondary_authors) {
        $author_array = explode(";", $pub->biblio_secondary_authors);
        foreach($author_array as $auth) {
          $doc .= "%E " . trim($auth) . "\r\n";
        } 
      } 
      if ($pub->biblio_publisher) $doc .= "%I " . trim($pub->biblio_publisher) . "\r\n";
      if (trim($pub->biblio_keywords)) $doc .= "%K " . trim($pub->biblio_keywords) . "\r\n";
      if ($pub->biblio_call_number) $doc .= "%L " . trim($pub->biblio_call_number) . "\r\n";
      if ($pub->biblio_accession_number) $doc .= "%M " . trim($pub->biblio_accession_number) . "\r\n";
      if ($pub->biblio_issue) $doc .= "%N " . trim($pub->biblio_issue) . "\r\n";
      if ($pub->biblio_pages) $doc .= "%P " . trim($pub->biblio_pages) . "\r\n";
      if ($pub->biblio_tertiary_title) $doc .= "%S " . trim($pub->biblio_tertiary_title) . "\r\n";
      if ($pub->biblio_url) $doc .= "%U " . trim($pub->biblio_url) . "\r\n";
      if ($pub->biblio_volume) $doc .= "%V " . trim($pub->biblio_volume) . "\r\n";
      $abst = "";
      if ($pub->biblio_abst_e) $abst .= trim($pub->biblio_abst_e);
      if ($pub->biblio_abst_f) $abst .= trim($pub->biblio_abst_f);
      if ($abst) {
        $search = array("/\r/", "/\n/");
        $replace = " ";
        $abst = preg_replace($search, $replace, $abst);
        $doc .= "%X " . $abst . "\r\n";
      } 
      if ($pub->biblio_tertiary_authors) {
        $author_array = explode(";", $pub->biblio_tertiary_authors);
        foreach($author_array as $auth) {
          $doc .= "%Y " . trim($auth) . "\r\n";
        } 
      } 
      if ($pub->biblio_notes) $doc .= "%Z " . trim($pub->biblio_notes) . "\r\n";
      if ($pub->biblio_edition) $doc .= "%7 " . trim($pub->biblio_edition) . "\r\n";
      if ($pub->biblio_date) $doc .= "%8 " . trim($pub->biblio_date) . "\r\n";
      if ($pub->biblio_type_of_work) $doc .= "%9 " . trim($pub->biblio_type_of_work) . "\r\n";
      if ($pub->biblio_isbn) $doc .= "%@ " . trim($pub->biblio_isbn) . "\r\n";

      $doc .= "\r\n";
    } 
   
  header('Content-type: 	application/x-endnote-refer');
  header('Content-Disposition:  filename="endnote.enw"');
  print utf8_decode($doc);
} 

function biblio_form_import() {

  if (biblio_access('import', $node)) { // && !user_access('administer nodes')) {

      $form['#attributes']['enctype'] = 'multipart/form-data';
      $form["file_upload"] = array(
        '#type' => 'file',
        '#title' => t('Import file'),
        '#default_value' => $edit['file_upload'],
        '#size' => 60,
      );
      $form['filetype'] = array(
        '#type' => 'radios',
        '#title' => t('File Type'),
        '#default_value' => $edit['filetype'],
        '#options' => array('tagged' => t('EndNote Tagged'),'ris' => t('RIS') , 'xml'=>t('EndNote 7 XML'), 'xml8'=>t('EndNote 8+ XML'), 'bib'=>t('BibTex')),
      );
   // Get the vocabularies  attached to the biblio node type ...
      $vocabularies = module_invoke('taxonomy', 'get_vocabularies', 'biblio');

      // ... and print a form to select the terms in each of them
      if (count($vocabularies)){
          $form['import_taxonomy'] = array(
            '#type' => 'fieldset',
            '#collapsible' => TRUE,
            '#collapsed' => FALSE,
            '#title' => t('Taxonomy Settings'),
            '#description' => t('You can select terms to assign to imported records and allow the mapping of keywords to taxonomy'),
          );

        $i=0;
        foreach ($vocabularies as $vocabulary) {
          $form['import_taxonomy']['vocabulary'.$i] = module_invoke('taxonomy', 'form', $vocabulary->vid, 0);     
          $form['import_taxonomy']['vocabulary'.$i++]['#description'] = t("Select taxonomy term to assigned to imported entries");
        }
        
        if (variable_get('biblio_keyword_freetagging', 0)){
          $freetag_vocab = module_invoke('taxonomy', 'get_vocabulary', variable_get('biblio_freetagging_vocab', 0));
          $msg = t('Keywords will be added to the').' "<b>'.$freetag_vocab->name.'</b>" '.t('vocabulary as specified ').l(t('on the settings page.'),'admin/settings/biblio');
        }else{
          $msg = t('Keywords will').' <b>'.t('NOT').'</b> '.t('be added to the vocabulary as specified ').l(t('on the settings page.'),'admin/settings/biblio');
        } 
        $form['import_taxonomy']['freetagging_information'] = array('#value' => '<div>'.$msg.'</div>');
        
        
       /*   $form['import_taxonomy']['keywordmap'] = array(
            '#type' => 'checkbox',
            '#title' => t('Use keywords for free tagging.'),
            '#return_value' => 1,
            '#default_value' => variable_get('biblio_keywordmap', 0),
            '#description' => t('Selecting this checkbox will cause the keywords, if any, to be used for free tagging'), );
      */
      }      
      
      $form['button'] = array(
        '#type' => 'submit',
        '#value' => t('Import')
      );

      return $form;
      //print theme('page', form($form, 'post', null, $attributes));
     
  } else {
    drupal_set_message("You are not authorized to access the biblio import page", 'error');

    print theme('page', '');
  } 
} 
function biblio_form_import_validate($form_id, $form_values) {

    $op = $form_values['op'];
    $filetype = $form_values['filetype'];
    $edit = $_POST;
    if (!file_check_upload('file_upload')){
        form_set_error('',t("You must provide a file name")); 
    }
    if($op == t('Import') && $filetype == '') {
       form_set_error('',t("You must select a file type"));
    }

}
function biblio_form_import_submit($form_id, $form_values) {
  $op = $form_values['op'];
    if ($form_values['op'] == t('Import') && isset($form_values['filetype'])) {
      $import = file_check_upload('file_upload');
      if ($import) {
        $import = file_save_upload($import);
        drupal_set_message($import->filename.t(" was uploaded"), 'status');

        // Concatenate all the terms of the different vocabularies
        // in a single array to be sent to _biblio_import
        $terms = array();
        foreach (array_keys($form_values) as $key) {
          if (preg_match('/(vocabulary[0-9]+)/', $key)){
            $terms[] = $form_values[$key];
          }
        }
        // Added the $terms argument
        // the array of terms to be attached to the node(s)
        $content = _biblio_import($import->filepath,$form_values['filetype'], $terms);
        file_delete($import->filepath);

      } else {
        drupal_set_message(t("File was NOT successfully uploaded"), 'error');
      } 
  }
}

function _biblio_import($filename = null,$type='tagged',$terms = null) {
  global $user;
  $node = array();
  if (file_exists($filename)) {
    if (($file_content = @file_get_contents($filename)) === false) {
        return false;
    } else {

      $options = variable_get('node_options_biblio',array('status'));
      
      $node['type']     = "biblio";
      $node['created']  = time();
      $node['changed']  = time();
      $node['comment']  = variable_get('comment_biblio',0); 
      $node['promote']  = in_array('promote',$options);
      $node['moderate'] = in_array('moderate',$options);
      $node['sticky']   = in_array('sticky',$options);
      $node['format']   = 0;
      $node['status']   = in_array('status',$options);
      $node['uid']      = $user->uid;

      switch($type){
      case 'tagged': // EndNote Tagged 
        require_once(drupal_get_path('module', 'biblio') . '/tagged_parser.inc');
        $node_ids  = _endnote_tagged_import($file_content,$node);
        break;
      case 'xml': // EndNote 7 XML
       $node_ids  = _endnote_XML_import($file_content ,$node, 7 ); 
      break;
      case 'xml8': // EndNote 8+ XML
       $node_ids  = _endnote_XML_import($file_content ,$node, 8 ); 
        break;
      case 'bib': // BibTex
       $node_ids  = _bibtex_import($file_content ,$node ); 
        break;
      case 'ris': // RIS
        require_once(drupal_get_path('module', 'biblio') . '/ris_parser.inc');
        $node_ids  = _ris_tagged_import($file_content,$node);
        break;
     }  
     if ($terms){
    	  // set the vocabulary for the returned nodes 
    	  foreach ($node_ids as $node_id){
    		  module_invoke('taxonomy', 'node_save', $node_id,  $terms);
    	  }
     }
      return $node_ids;
    }
  } else {
    return false;
  }
}

function _endnote_XML_import(&$data ,$nodedata, $version = 8) {
global $user,$records, $rec_count,$node_array,$node,$node_id;
  $node_array = array();
  $node = $nodedata;
  $xml_parser = drupal_xml_parser_create($data);

// use case-folding so we are sure to find the tag in 
  xml_parser_set_option($xml_parser, XML_OPTION_CASE_FOLDING, false);
  xml_parser_set_option($xml_parser, XML_OPTION_SKIP_WHITE, true);
  if ($version == 8){
    require_once(drupal_get_path('module', 'biblio') . '/endnote8_parser.inc');
    xml_set_element_handler($xml_parser, "en8_startElement", "en8_endElement");
    xml_set_character_data_handler($xml_parser, "en8_characterData");
    xml_parse($xml_parser, $data,1);
  }elseif ($version == 7){
    require_once(drupal_get_path('module', 'biblio') . '/endnote7_parser.inc');

    xml_parse_into_struct($xml_parser, $data, $values);

    en7_parse($values,$node_array,$node) ;

  }

  xml_parser_free($xml_parser);

  $node_ids = _biblio_save_imported_nodes($node_array);

  return ($node_ids);
}
 
function _bibtex_import(&$data, $node) {
require_once(drupal_get_path('module', 'biblio') . '/bibtex.php');

  $node_array = array();
  
  $bibtex = new Structures_BibTex();
  $bibtex->loadString($data);
  
  
  $bibtex->parse();
  if ($bibtex->amount()){
    $bibtex->bib2node($node_array, $node);
    $node_ids = _biblio_save_imported_nodes($node_array);
  }
  return $node_ids;
} 

function _biblio_save_imported_nodes(&$node_array){

  if (function_exists('node_save')) {
    foreach ($node_array as $node) {
      $node = (object)$node;
      if (variable_get('biblio_keyword_freetagging',0) && variable_get('biblio_freetagging_vocab',0)){
        $vid = variable_get('biblio_freetagging_vocab',0);
        $node->taxonomy['tags'][$vid] = $node->biblio_keywords;
      }
      node_save($node);
      if ($node->nid) { 
         $node_ids[] = $node->nid;
      }
    } 
  }
  drupal_set_message(t("Succesfully imported ").count($node_ids).t(" entries."), 'status');

  return $node_ids;
}
 
function biblio_get_db_fields() {
  $fields = array();
  $fields[] = 'nid';  
  $fields[] = 'vid';
  $fields[] = 'biblio_type';
  $result = db_query('SELECT name FROM {biblio_fields} ');
  while ($field = db_fetch_array($result)){
    $fields[] = $field['name'];
  }
  return $fields ;
} 
function _biblio_author_links($author) {
$attr = null;
if (isset($_GET['sort'])) {
  $attr .= "sort=" . $_GET['sort'];
} 
if (isset($_GET['order'])) {
  $attr .= $attr?"&":"";
  $attr .= "order=" . $_GET['order'];
} 

$html = "";
$author_array = explode(";", $author);
foreach($author_array as $auth) {
  if ($i) $html .= "; ";
  $i++;
  if (strstr($auth, ",")) {
    $parts = split(",", $auth);
    $lastname = $parts[0];
  } else {
    $parts = split(" ", $auth);
    $lastname = end($parts);
  } 
  // list($lastname, $init) = split(",", $auth);
  $base =  variable_get('biblio_base', 'biblio');
  $html .= l(trim($auth), "$base/author/" . trim($lastname),null, $attr);
} 
return $html;
} 
function biblio_author_index_shutdown(){
  global  $biblio_last_nid;

  if ($biblio_last_nid) {
    variable_set('biblio_ai_last_nid', $biblio_last_nid);
  }

}
function biblio_update_author_index() {
  global  $biblio_last_nid;

  //register_shutdown_function('biblio_author_index_shutdown');
  $biblio_last_nid = variable_get('biblio_ai_last_nid', 0);
  $biblio_max_count = variable_get('biblio_ai_max_count', 100);
  $count = 0;
  $result  = db_query("SELECT nid, biblio_authors FROM {biblio} WHERE nid > %d",$biblio_last_nid);
  while ( ($row = db_fetch_object($result)) && ($count < $biblio_max_count) ){
    $author_array = explode(";", $row->biblio_authors);
    $rank = 0;
    foreach($author_array as $auth) {
      $rank++;
      if (strstr($auth, ",")) {
        $parts = split(",", $auth);
        $lastname = $parts[0];
      } else {
        $parts = split(" ", $auth);
        $lastname = end($parts);
      } 
      _biblio_author_index_insert($row->nid, $lastname,$rank);
      $biblio_last_nid = $row->nid;  
    }
    $count++;
  } 
    variable_set('biblio_ai_last_nid', $biblio_last_nid);

  return ;
} 

function _biblio_author_index_insert($nid, $author,$rank) {
  $uc_author = trim(drupal_strtoupper($author));
  $result = db_query("SELECT * FROM {biblio_author_index} WHERE author = '%s'",$uc_author);
  $author_exist = db_num_rows($result);

  if ($author_exist){
    $row = db_fetch_object($result);
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d,%d,%d)",$nid,$row->aid,$rank);   
  }else{
    $aid = db_next_id('{biblio_author_index}_aid');
    $result = db_query("INSERT INTO {biblio_author_index} (`aid`,`author`) VALUES (%d,'%s')",$aid,$uc_author);   
    $result = db_query("INSERT INTO {biblio_has_author} (`nid`,`aid`,`rank`) VALUES (%d, %d, %d)",$nid,$aid,$rank);   
  
  }
  return ;
}
function _biblio_keyword_links($keywords) {
  if (isset($_GET['sort'])) {
    $sort = "?sort=" . $_GET['sort'];
  } 
  
  $html = "";
  if (strstr($keywords,';')){
    $keyword_array = explode(";", $keywords);
  }elseif(strstr($keywords,',')){
    $keyword_array = explode(",", $keywords);  
  }else{
    $keyword_array = explode(" ", $keywords);  
  }
  foreach($keyword_array as $kw) {
    if ($i) $html .= "; ";
    $i++;
    $base =  variable_get('biblio_base', 'biblio');
    $html .= l(trim($kw), "$base/keyword/" . trim($kw) . $sort);
  } 
  return $html;
}

function _biblio_parse_authors($authors) {
$and = array(" and", " And", " AND");
$authors = str_replace($and, ", ", $authors); // change the word "and" to a comma
$authors = str_replace(" ,", ",", $authors); // fix some potential typos
$authors = str_replace(",,", ",", $authors); // ditto 
// $authors = str_replace(";",",",$authors);
$chunks = explode(";", $authors); // split the authors on the semicolon
$num_chunks = count($chunks);

for($i = 0;  $i < count($chunks);  $i++) {
  $suffix = _biblio_get_suffix($chunks[$i]); // get and strip out the suffix
  $prefix = _biblio_get_prefix($chunks[$i]); // get and strip out the prefix
  if (strstr($chunks[$i], ",")) { // we probably have lastname first
    $subchunks = explode(",", trim($chunks[$i]));
    $lastname = $subchunks[0];
    $subchunks = explode(" ", trim($subchunks[1]));
    $initials = "";
    for ($j = 0; $j < count($subchunks) ;  $j++) {
      if (substr_count($subchunks[$j], '.')) {
        $initials .= $subchunks[$j];
      } else {
        $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
      } 
    } 
  } else { // we have some form of firstname first (Fistname I. Lastname)
    $subchunks = explode(" ", trim($chunks[$i]));
    $lastname = end($subchunks);
    $initials = "";
    for ($j = 0;
      $j < count($subchunks) - 1 ;
      $j++) {
      if (substr_count($subchunks[$j], '.')) {
        $initials .= $subchunks[$j];
      } else {
        $initials .= drupal_substr($subchunks[$j], 0, 1) . ".";
      } 
    } 
  } 
  $chunks[$i] = trim($prefix . ' ' . $lastname . ', ' . $initials . ' ' . $suffix);
} 
return implode("; ", $chunks);
} 
function _biblio_get_suffix(&$name) {
$suffix = null;
  if (preg_match("/[, \.]+(Jr|Sr|Snr)\.?\s*$/", $name, $match)) {
    $suffix = $match[0];
    $Text = str_replace($Suffix, "", $name);
  } elseif (preg_match("/([, \.]+)(Jr|Sr|Snr)[. ]/", $name, $match)) {
    $suffix = $match[1];
    $name = str_replace($Suffix, "", $name);
  } 

return $suffix;
} 
function _biblio_get_prefix(&$name) {
  $prefix = null;
  $name = " " . $name;
  $prefs = array(" Van ", " van ", " von ", " den ", " der ", " de ", " De ", " ter ", " Ter ", "Vander ");
  if (strstr($name, " Van ")) $prefix .= "Van ";
  if (strstr($name, " van ")) $prefix .= "van ";
  if (strstr($name, " Vander ")) $prefix .= "Vander ";
  if (strstr($name, " von ")) $prefix .= "von ";
  if (strstr($name, " de ")) $prefix .= "de ";
  if (strstr($name, " De ")) $prefix .= "De ";
  if (strstr($name, " den ")) $prefix .= "den ";
  if (strstr($name, " der ")) $prefix .= "der ";
  if (strstr($name, " ter ")) $prefix .= "ter ";
  if (strstr($name, " Ter ")) $prefix .= "Ter ";
  if (strlen($prefix)) $name = str_replace($prefs, "", $name);
  $name = trim($name);
  return $prefix;
} 

function author_test(){
    $result  = db_query("SELECT nid, biblio_authors FROM {biblio} ");
    $carray = array();
    while ($row = db_fetch_object($result)){
    //    $carray = explode(";",$authors->biblio_authors);
      //  $creators = _parse_author_array($carray);
      _biblio_author_index($row->nid,$row->biblio_authors);
      // echo $authors->nid;
         
    }
    $creators = _parse_author_array($carray);
}
function _parse_author_array($authorArray)
{
//	$input = trim($input);
// split on ' and ' 
//	$authorArray = preg_split("/\s(and)\s/i", $input);
// check if there's anything that looks like et. al
  $count=1;
	foreach($authorArray as $value)
	{
		$appellation = $prefix = $surname = $firstname = $initials = '';
		$author = explode(",", preg_replace("/\s{2,}/", ' ', trim($value)));
		$size = sizeof($author);
// No commas therefore something like Mark Grimshaw, Mark Nicholas Grimshaw, M N Grimshaw, Mark N. Grimshaw
		if($size == 1)
		{
			$author = split(" ", $value);
// last of array is surname (no prefix if entered correctly)
			$surname = array_pop($author);
		}
// Something like Grimshaw, Mark or Grimshaw, Mark Nicholas  or Grimshaw, M N or Grimshaw, Mark N.
		else if($size == 2)
		{
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
// If $size is > 2, we're looking at something like Bush, George W, III
		else
		{
// last of array is 'Jr.', 'IV' etc.
			$appellation = array_pop($author);
// first of array is surname (perhaps with prefix)
			list($surname, $prefix) = _grabSurname(array_shift($author));
		}
		$remainder = join(" ", $author);
		list($firstname, $initials) = _grabFirstnameInitials($remainder);
		$surname = $surname . ' ' . $appellation;
		$creators[] = array('first_name'=> "$firstname", 
                        'initials'  => "$initials", 
                        'last_name' => "$surname", 
                        'prefix'    => "$prefix",
                        'order'     => "$count");
    $count++;
	}
	if(isset($creators))
		return $creators;
	return FALSE;
}
// grab firstname and initials which may be of form "A.B.C." or "A. B. C. " or " A B C " etc.
function _grabFirstnameInitials($remainder)
{
	$firstname = $initials = '';
	$array = split(" ", $remainder);
	foreach($array as $value)
	{
		if(preg_match("/[a-zA-Z]{2,}/", trim($value)))
			$firstnameArray[] = trim($value);
		else
			$initialsArray[] = str_replace(".", " ", trim($value));
	}
	if(isset($initialsArray))
	{
		foreach($initialsArray as $initial)
			$initials .= ' ' . trim($initial);
	}
	if(isset($firstnameArray))
		$firstname = join(" ", $firstnameArray);
	return array($firstname, $initials);
}
// surname may have title such as 'den', 'von', 'de la' etc. - characterised by first character lowercased
function _grabSurname($input)
{
	$surnameArray = split(" ", $input);
	foreach($surnameArray as $value)
	{
		$firstChar = substr($value, 0, 1);
		if((ord($firstChar) >= 97) && (ord($firstChar) <= 122))
			$prefix[] = $value;
		else
			$surname[] = $value;
	}
	$surname = join(" ", $surname);
	if(isset($prefix))
	{
		$prefix = join(" ", $prefix);
		return array($surname, $prefix);
	}
	return array($surname, FALSE);
}

function biblio_views_tables(){

}
function biblio_views_arguments(){

}

function biblio_views_default_views(){

}
function biblio_nodeapi($node, $op){
  switch ($op){
  case 'delete revision':
      db_query('DELETE FROM {biblio} WHERE vid = %d', $node->vid);
      break;
      
  }

}

 /*******************************************
  * Filter
  * Largely inspired from the footnote module 
  *  
 *******************************************/
 
function _biblio_citekey_print($citekey){
   $nid = db_fetch_object(db_query("SELECT nid FROM {biblio} WHERE biblio_citekey = '%s' ORDER BY vid DESC", $citekey));
   if ($nid->nid > 0){
     $node = node_load($nid->nid);
     return theme('biblio_short', $node);
   } else {
     return t("Citekey: ").$citekey.t(" not found");
   }
 
}
 
 
 /**
  * Implementation of hook_filter_tips().
  *
  * This hook allows filters to provide help text to users during the content
  * editing process. Short tips are provided on the content editing screen, while
  * long tips are provided on a separate linked page. Short tips are optional,
  * but long tips are highly recommended.
  */
function biblio_filter_tips($delta, $format, $long = FALSE) {
   switch ($delta) {
     case 0:
       if ($long) {
         return t('You can cite references directly into texts with <code>&lt;bib&gt;citekey&lt;/bib&gt;</code>. This will be replaced with a running number (the publication reference) and the publication referenced by the citekey within the &lt;bib&gt; tags will be print to the bottom of the page (the reference).');
       }
       else {
         return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');
       }
       break;
   }
}
 
 /**
  * Implementation of hook_filter().
  *
  * The bulk of filtering work is done here. This hook is quite complicated, so
  * we'll discuss each operation it defines.
  */
function biblio_filter($op, $delta = 0, $format = -1, $text = '') {
   // The "list" operation provides the module an opportunity to declare both how
   // many filters it defines and a human-readable name for each filter. Note that
   // the returned name should be passed through t() for translation.
   if ($op == 'list') {
     return array(
       0 => t('References &lt;bib&gt;'),
     );
   }
   if ($op == 'no cache') { return true; }
  
   // All operations besides "list" provide a $delta argument so we know which
   // filter they refer to. We'll switch on that argument now so that we can
   // discuss each filter in turn.
   switch ($delta) {
 
     // First is the html footnotes filter
     case 0:
 
       switch ($op) {
         // This description is shown in the administrative interface, unlike the
         // filter tips which are shown in the content editing interface.
         case 'description':
           return t('Use &lt;bib&gt;...&lt;/bib&gt; to insert automatically numbered references.');
 
         // We don't need the "prepare" operation for this filter, but it's required
         // to at least return the input text as-is.
         //TODO: May need to escape <fn> if we use HTML filter too, but Footnotes could be first
         case 'prepare':
           return $text;
 
         // The actual filtering is performed here. The supplied text should be
         // returned, once any necessary substitutions have taken place.
         case 'process':
           $text = preg_replace_callback('|<bib>(.*?)</bib>|s', '_biblio_filter_replace_callback', $text);
           
           //Replace tag <footnotes> with the list of footnotes.
           //If tag is not present, by default add the footnotes at the end.
           //Thanks to acp on drupal.org for this idea. see http://drupal.org/node/87226 
           $footer = '';
           $footer = _biblio_filter_replace_callback(NULL, 'output footer');
           if( preg_match( '/<bibliography(\/( )?)?>/', $text ) > 0 ) {
             $text = preg_replace('/<bibliography(\/( )?)?>/', $footer, $text, 1);
             return $text;
           }
           else {
             return $text . "\n\n" . $footer;
           }
       }
       break;
   }
}
 
 
 /**
  * Helper function called from preg_replace_callback() above
  *
  * Uses static vars to temporarily store footnotes found.
  * In my understanding, this is not threadsafe?!
  */
function _biblio_filter_replace_callback( $matches, $op = '' ) {
   static $n = 0;
   static $store_matches = array();
   $str = '';
   
   if( $op == 'output footer' ) {
     drupal_add_css(drupal_get_path('module', 'biblio').'/biblio.css');
     if( $n > 0 ) {
       $str = '<p><hr /><p><h3>'.t('References').'</h3>';
       $str .= '<div class="references"><ol>';
       for( $m = 1; $m <= $n; $m++ ){
         $str .= '<li id="reference' . $m . '">' . _biblio_citekey_print($store_matches[ $m - 1 ]) . " </li>\n\n";
       }
       $str .= '</ol></div>';
     }
     $n = 0;
     $store_matches = array();
     return $str;
   }
 
   //default op: act as called by preg_replace_callback()
   array_push( $store_matches, $matches[1] );
   $n++;
   $allowed_tags = array();
   $title = filter_xss($matches[1], $allowed_tags);
   //html attribute cannot contain quotes
   $title = str_replace('"', "&quot;", $title);
   //remove newlines. Browsers don't support them anyway and they'll confuse line break converter in filter.module
   $title = str_replace("\n", " ", $title);
   $title = str_replace("\r", "", $title);
   //return '<sup class="see_reference" title="'. $title .'"><a href="#reference' . $n . '">' . $n . '</a></sup>';  
   //$text = '<span><a href="#reference' . $n . '">[' . $n . ']</a> </span>';
   //$text = '<span>[' . $n . ']</span>';
   //$text .= '<span class="hovertip">'._biblio_citekey_print($title) .'</span>';
 
   $text = '<span hovertip="reference'. $n .'">[' . $n .']</span>';
   if (module_exists('hovertip')) { 
     $text .= '<div id="reference'. $n .'" class="hovertip"><h1>Reference</h1>'._biblio_citekey_print($title) .'</div>';
   }
   return $text;
 
}
function biblio_taxonomy($op, $type, $array = NULL) { 

  if ($op == 'delete' && $term['vid'] == variable_get('biblio_freetagging_vocab',0)) {
    switch ($type) {
      case 'term':
        break;
      case 'vocabulary':
        variable_del('biblio_keyword_freetagging');
        variable_del('biblio_freetagging_vocab');
        break;
    
    }
    
  }  

}
